<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法刷题3</title>
      <link href="/2023/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%983/"/>
      <url>/2023/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h4 id="2373-矩阵中的局部最大值"><a href="#2373-矩阵中的局部最大值" class="headerlink" title="2373. 矩阵中的局部最大值"></a><a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/">2373. 矩阵中的局部最大值</a></h4><p>难度简单34收藏分享切换为英文接收动态反馈</p><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p><p>生成一个大小为 <code>(n - 2) x (n - 2)</code> 的整数矩阵 <code>maxLocal</code> ，并满足：</p><ul><li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li></ul><p>换句话说，我们希望找出 <code>grid</code> 中每个 <code>3 x 3</code> 矩阵中的最大值。</p><p>返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/06/21/ex1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]</span><br><span class="line">输出：[[9,9],[8,6]]</span><br><span class="line">解释：原矩阵和生成的矩阵如上图所示。</span><br><span class="line">注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]</span><br><span class="line">输出：[[2,2,2],[2,2,2],[2,2,2]]</span><br><span class="line">解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。</span><br></pre></td></tr></table></figure><p>直接模拟即可</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">largestLocal</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n<span class="number">-2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">-2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">                <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=i+<span class="number">2</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> z=j;z&lt;=j+<span class="number">2</span>;z++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=<span class="built_in">max</span>(grid[k][z],temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i][j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：二维vector数组的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; 名字(size1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size2, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 矩阵计算 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题2</title>
      <link href="/2023/02/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%982/"/>
      <url>/2023/02/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h2><h4 id="2363-合并相似的物品"><a href="#2363-合并相似的物品" class="headerlink" title="2363. 合并相似的物品"></a><a href="https://leetcode.cn/problems/merge-similar-items/">2363. 合并相似的物品</a></h4><p>给你两个二维整数数组 <code>items1</code> 和 <code>items2</code> ，表示两个物品集合。每个数组 <code>items</code> 有以下特质：</p><ul><li><code>items[i] = [valuei, weighti]</code> 其中 <code>valuei</code> 表示第 <code>i</code> 件物品的 <strong>价值</strong> ，<code>weighti</code> 表示第 <code>i</code> 件物品的 <strong>重量</strong> 。</li><li><code>items</code> 中每件物品的价值都是 <strong>唯一的</strong> 。</li></ul><p>请你返回一个二维数组 <code>ret</code>，其中 <code>ret[i] = [valuei, weighti]</code>， <code>weighti</code> 是所有价值为 <code>valuei</code> 物品的 <strong>重量之和</strong> 。</p><p><strong>注意：</strong><code>ret</code> 应该按价值 <strong>升序</strong> 排序后返回。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]</span><br><span class="line">输出：[[1,6],[3,9],[4,5]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。</span><br><span class="line">value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。</span><br><span class="line">value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。</span><br><span class="line">所以，我们返回 [[1,6],[3,9],[4,5]] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]</span><br><span class="line">输出：[[1,4],[2,4],[3,4]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。</span><br><span class="line">value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">所以，我们返回 [[1,4],[2,4],[3,4]] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]</span><br><span class="line">输出：[[1,7],[2,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。</span><br><span class="line">所以，我们返回 [[1,7],[2,4],[7,1]] 。</span><br></pre></td></tr></table></figure><p>思路：使用哈希表将相同价值的重量加在一起，最后再排序即可</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items2) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; judge;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:items1)</span><br><span class="line">        &#123;</span><br><span class="line">            judge[t[<span class="number">0</span>]]+=t[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:items2)</span><br><span class="line">        &#123;</span><br><span class="line">            judge[t[<span class="number">0</span>]]+=t[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=judge.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(;it!=judge.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;it-&gt;first,it-&gt;second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题1</title>
      <link href="/2023/02/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%981/"/>
      <url>/2023/02/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="1144-递减元素使数组呈锯齿状"><a href="#1144-递减元素使数组呈锯齿状" class="headerlink" title="1144. 递减元素使数组呈锯齿状"></a>1144. 递减元素使数组呈锯齿状</h2><p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p><p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p><ul><li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li><li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li></ul><p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以把 2 递减到 0，或把 3 递减到 1。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：nums = [9,6,1,6,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="思路：枚举-贪心"><a href="#思路：枚举-贪心" class="headerlink" title="思路：枚举+贪心"></a>思路：枚举+贪心</h2><p>​分别算出偶数索引大和奇数索引大的两种情况需要操作的最小次数，比较求之即可。</p><h2 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums1=nums; <span class="comment">//防止第一次计算时数组变化，备份一份</span></span><br><span class="line">        <span class="type">int</span> res1=<span class="number">0</span>,res2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//奇数索引最大时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res1+=nums[i]-nums[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums[i]=nums[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res1+=nums[i]-nums[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums[i]=nums[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//偶数索引最大时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums1[i]&gt;=nums1[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res2+=nums1[i]-nums1[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums1[i]=nums1[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums1[i]&gt;=nums1[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res2+=nums1[i]-nums1[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums1[i]=nums1[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路考试范围</title>
      <link href="/2023/01/06/%E7%94%B5%E8%B7%AF%E8%80%83%E8%AF%95/"/>
      <url>/2023/01/06/%E7%94%B5%E8%B7%AF%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>交作业时间 雨课堂  还有感想意见也要写<br>电路考试题型<br>8个小主观题  6*8&#x3D;48<br>必考内容<br>直流<br>第一章 简单直流电路的分析 KCL KVL 功率<br>第二章 对象化简 二端口网络<br>第四章 叠加定理<br>交流<br>相量法简单计算 简单交流电路<br>谐振（去耦 理想变压器等）<br>非正弦交流 公式<br>三相电路中间的量表法</p><p>五个大题<br>必考<br>1.节点法和回路法（2选1）<br>2.交流电路分析（相量图）<br>3.三相电路分析（对称或简单不对称）计算器<br>4.一阶电路分析<br>5.二端口网络&#x2F;定理综合应用 等 待定</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建历程</title>
      <link href="/2022/12/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"/>
      <url>/2022/12/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-12-28"><a href="#2022-12-28" class="headerlink" title="2022.12.28"></a>2022.12.28</h1><p>正式建立博客并设置了背景，添加搜索功能，为顶部底部添加透明css文件等一系列美化措施。</p><h1 id="2023-2-18-2023-2-28"><a href="#2023-2-18-2023-2-28" class="headerlink" title="2023.2.18-2023.2.28"></a>2023.2.18-2023.2.28</h1><ul><li>1.加入了Aplayer播放器</li><li>2.个人卡渐变</li><li>3.首页文章分栏显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/12/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>##第一篇文章</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
