<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>力扣hot100-15</title>
      <link href="/2023/05/11/%E5%8A%9B%E6%89%A3hot100-15/"/>
      <url>/2023/05/11/%E5%8A%9B%E6%89%A3hot100-15/</url>
      
        <content type="html"><![CDATA[<h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h4><p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin">深拷贝</a><strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。</strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p><p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p><p>返回复制链表的头节点。</p><p>用一个由 <code>n</code> 个节点组成的链表来表示输入&#x2F;输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p><ul><li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li><li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li></ul><p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>-104 &lt;= Node.val &lt;= 104</code></li><li><code>Node.random</code> 为 <code>null</code> 或指向链表中的节点。</li></ul><p><strong>思路：</strong></p><p>因为本题存在random随机节点，深拷贝（关系也要拷贝）的时候，随机指的点可能还没有创建，所以我们不能遍历复制。</p><p>一种方法是：先创建所有节点，用哈希表存储节点名称和具体节点的关系。</p><p>然后遍历原链表，对于原来的关系进行拷贝即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;Node*,Node*&gt; s;</span><br><span class="line"></span><br><span class="line">        Node* temp=head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* t=<span class="keyword">new</span> <span class="built_in">Node</span>(temp-&gt;val);</span><br><span class="line">            s[temp]=t;</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp=head;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[temp]-&gt;next=s[temp-&gt;next];</span><br><span class="line">            s[temp]-&gt;random=s[temp-&gt;random];</span><br><span class="line">            temp=temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s[head];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-12</title>
      <link href="/2023/05/10/%E5%8A%9B%E6%89%A3hot100-12/"/>
      <url>/2023/05/10/%E5%8A%9B%E6%89%A3hot100-12/</url>
      
        <content type="html"><![CDATA[<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p> <strong>思路：</strong></p><p>按照链表长度为奇数偶数分别判断 前半段入栈 后半段相同即出栈 最后判断栈是否为空即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">        ListNode* t=head;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t=t-&gt;next;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;head-&gt;val&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;val==s.<span class="built_in">top</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(head!=<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;val==s.<span class="built_in">top</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-14</title>
      <link href="/2023/05/10/%E5%8A%9B%E6%89%A3hot100-14/"/>
      <url>/2023/05/10/%E5%8A%9B%E6%89%A3hot100-14/</url>
      
        <content type="html"><![CDATA[<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>递归</p><p>结束条件：当前待处理链表为空或只剩一个元素</p><p>每次 取head的next</p><p>然后head的下一个其实是下一组交换的结点</p><p>next的下一个是head</p><p>递归处理即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* next=head-&gt;next;</span><br><span class="line">        head-&gt;next=<span class="built_in">swapPairs</span>(next-&gt;next);</span><br><span class="line">        next-&gt;next=head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-13</title>
      <link href="/2023/05/10/%E5%8A%9B%E6%89%A3hot100-13/"/>
      <url>/2023/05/10/%E5%8A%9B%E6%89%A3hot100-13/</url>
      
        <content type="html"><![CDATA[<h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p> <strong>思路：</strong></p><p>用哈希表存储结点和对应的索引，当重复出现的时候直接返回这个结点即可。否则返回空</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;ListNode*,<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;head-&gt;val&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(s[head]) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                s[head]=i;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-09</title>
      <link href="/2023/05/09/%E5%8A%9B%E6%89%A3hot100-09/"/>
      <url>/2023/05/09/%E5%8A%9B%E6%89%A3hot100-09/</url>
      
        <content type="html"><![CDATA[<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li></ul><p><strong>思路：</strong></p><p>模拟 只能说折磨 参考以下思路比较好写代码</p><p>分别上下左右遍历，并不断缩小外框。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mm=<span class="number">0</span>,nn=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=nn;i&lt;=n;++i) res.<span class="built_in">push_back</span>(matrix[mm][i]);</span><br><span class="line">            <span class="keyword">if</span>(++mm&gt;m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=mm;i&lt;=m;++i) res.<span class="built_in">push_back</span>(matrix[i][n]);</span><br><span class="line">            <span class="keyword">if</span>(--n&lt;nn) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=nn;--i) res.<span class="built_in">push_back</span>(matrix[m][i]);</span><br><span class="line">            <span class="keyword">if</span>(--m&lt;mm) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=mm;--i) res.<span class="built_in">push_back</span>(matrix[i][nn]);</span><br><span class="line">            <span class="keyword">if</span>(++nn&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-08</title>
      <link href="/2023/05/09/%E5%8A%9B%E6%89%A3hot100-08/"/>
      <url>/2023/05/09/%E5%8A%9B%E6%89%A3hot100-08/</url>
      
        <content type="html"><![CDATA[<h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h4><p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p><p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,0]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,-1,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,8,9,11,12]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>思路：</strong></p><p>① 时间复杂度On 空间复杂度On</p><p>哈希表 然后从1开始依次判断</p><p>② 时间复杂度On 空间复杂度O1</p><p>改变数组</p><p>长度为n的数组 结果必在[1-n+1]内，所以负数全部变为n+1，然后将在1-n里的数在对应的位置上做上标记，并将原本这个位置上的数变为它的绝对值的负数（要取绝对值，因为中间会变负数），最后判断第一个大于0的位置i，返回i+1。如果没有就返回n+1.</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t&lt;=<span class="number">0</span>) t=n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tt=<span class="built_in">abs</span>(t);</span><br><span class="line">            <span class="keyword">if</span>(tt&lt;=n) nums[tt<span class="number">-1</span>]=-(<span class="built_in">abs</span>(nums[tt<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-11</title>
      <link href="/2023/05/09/%E5%8A%9B%E6%89%A3hot100-11/"/>
      <url>/2023/05/09/%E5%8A%9B%E6%89%A3hot100-11/</url>
      
        <content type="html"><![CDATA[<h4 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h4><p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p><ul><li>每行的元素从左到右升序排列。</li><li>每列的元素从上到下升序排列。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= n, m &lt;= 300</code></li><li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><p><strong>思路：</strong></p><p>① 因为每行每列都是有序排列，所以可以对每一行采用二分查找。</p><p>② 分治法，每次在对角线找到第一个小于target的数，以他为分界线划分为四块区域。</p><p>其中 左上角一定小于target，右下角一定大于target。那么只需要对左下和右上采用相同的分治手段即可。</p><p><strong>代码：</strong></p><p>①</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m=matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it=<span class="built_in">lower_bound</span>(matrix[i].<span class="built_in">begin</span>(),matrix[i].<span class="built_in">end</span>(),target);</span><br><span class="line">            <span class="keyword">if</span>(it!=matrix[i].<span class="built_in">end</span>() &amp;&amp; *it==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>②</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> nLeft,<span class="type">int</span> nRight,<span class="type">int</span> nTop,<span class="type">int</span> nBottom,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> nRowIndex = nBottom;</span><br><span class="line">        <span class="type">int</span> nColIndex = nRight;</span><br><span class="line">        <span class="keyword">if</span>(nRowIndex &lt; <span class="number">0</span> || nColIndex &lt; <span class="number">0</span> || nLeft &gt; nRight||nTop &gt; nBottom)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(nRowIndex &gt;= nTop &amp;&amp; nColIndex &gt;= nLeft)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[nRowIndex][nColIndex]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nRowIndex == nBottom &amp;&amp;nColIndex == nRight)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[nRowIndex][nColIndex]==target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nRowIndex--;</span><br><span class="line">                nColIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> ret1=<span class="built_in">search</span>(matrix,nColIndex+<span class="number">1</span>,nRight,nTop,nRowIndex,target);</span><br><span class="line">        <span class="keyword">if</span>(ret1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> ret2=<span class="built_in">search</span>(matrix,nLeft,nColIndex,nRowIndex+<span class="number">1</span>,nBottom,target);</span><br><span class="line">        <span class="keyword">if</span>(ret2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> nRowSize = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == nRowSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> nColSize = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(matrix,<span class="number">0</span>,nColSize<span class="number">-1</span>,<span class="number">0</span>,nRowSize<span class="number">-1</span>,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-10</title>
      <link href="/2023/05/09/%E5%8A%9B%E6%89%A3hot100-10/"/>
      <url>/2023/05/09/%E5%8A%9B%E6%89%A3hot100-10/</url>
      
        <content type="html"><![CDATA[<h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h4><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><p><strong>思路：</strong></p><p>先上下翻转，然后按照对角线交换元素</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> re=n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;re;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[n-i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-03</title>
      <link href="/2023/05/06/%E5%8A%9B%E6%89%A3hot100-03/"/>
      <url>/2023/05/06/%E5%8A%9B%E6%89%A3hot100-03/</url>
      
        <content type="html"><![CDATA[<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p><strong>思路：</strong></p><p>采用优先队列记录每个元素的值和它的下标，优先队列的堆顶值就是最大值</p><p>每次滑动窗口滑动就相当于优先队列添加进一个值，当然此时的最大值不一定在滑动窗口内，因此我们要一直出队直到堆顶的值在滑动窗口内（下标&lt;&#x3D;i-k）</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(nums[i],i);</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">top</span>().second&lt;=i-k)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-04</title>
      <link href="/2023/05/06/%E5%8A%9B%E6%89%A3hot100-04/"/>
      <url>/2023/05/06/%E5%8A%9B%E6%89%A3hot100-04/</url>
      
        <content type="html"><![CDATA[<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br><span class="line">解释：整个字符串 s 是最小覆盖子串。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == s.length</code></li><li><code>n == t.length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p> <strong>思路：</strong></p><p>定义一个滑动窗口，两个哈希表 </p><p>ht表示t中的字符各出现的次数</p><p>开始创建一个滑动窗口 左侧为j 右侧为i</p><p>不断先向右移动滑动窗口</p><p>每次移动时，如果还没满足，设置一个数量变量cnt 当滑动窗口内只包含t的一部分时 让cnt++</p><p>如果满足了，那么让左边j向右收缩，直到不满足t的临界</p><p>设置一个res字符串，不断更新最短的满足t的字符串</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hs,ht;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a:t) ht[a]++;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            hs[s[i]]++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hs[s[i]]&lt;=ht[s[i]]) cnt++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(hs[s[j]]&gt;ht[s[j]]) hs[s[j++]]--;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cnt==t.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">empty</span>()||i-j+<span class="number">1</span>&lt;res.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    res=s.<span class="built_in">substr</span>(j,i-j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-05</title>
      <link href="/2023/05/06/%E5%8A%9B%E6%89%A3hot100-05/"/>
      <url>/2023/05/06/%E5%8A%9B%E6%89%A3hot100-05/</url>
      
        <content type="html"><![CDATA[<h4 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h4><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= intervals.length &lt;= 104</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 104</code></li></ul><p><strong>思路:</strong></p><p>先将区间按照左端点排序</p><p>然后依次添加 每次添加时判定即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a,vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=res[i<span class="number">-1</span>-cnt][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res[i<span class="number">-1</span>-cnt][<span class="number">1</span>]=<span class="built_in">max</span>(res[i<span class="number">-1</span>-cnt][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-06</title>
      <link href="/2023/05/06/%E5%8A%9B%E6%89%A3hot100-06/"/>
      <url>/2023/05/06/%E5%8A%9B%E6%89%A3hot100-06/</url>
      
        <content type="html"><![CDATA[<h4 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h4><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><p><strong>思路： （原地）</strong></p><p>三次翻转操作：</p><p>第一次 全体翻转</p><p>第二次 翻转 0—k % n-1的数组</p><p>第三次 翻转 k%n —n-1的数组</p><p><img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230506202637146.png" alt="image-20230506202637146"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-07</title>
      <link href="/2023/05/06/%E5%8A%9B%E6%89%A3hot100-07/"/>
      <url>/2023/05/06/%E5%8A%9B%E6%89%A3hot100-07/</url>
      
        <content type="html"><![CDATA[<h4 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h4><p>难度中等1438收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请<strong>不要使用除法，</strong>且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,1,0,-3,3]</span><br><span class="line">输出: [0,0,9,0,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li></ul><p><strong>思路：</strong></p><p>分别记录每个元素左边的乘积和右边的乘积，在一次遍历时就分别处理</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i]*=l;</span><br><span class="line">            l*=nums[i];</span><br><span class="line"></span><br><span class="line">            res[n<span class="number">-1</span>-i]*=r;</span><br><span class="line">            r*=nums[n<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题29</title>
      <link href="/2023/04/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9829/"/>
      <url>/2023/04/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9829/</url>
      
        <content type="html"><![CDATA[<h4 id="1048-最长字符串链"><a href="#1048-最长字符串链" class="headerlink" title="1048. 最长字符串链"></a><a href="https://leetcode.cn/problems/longest-string-chain/">1048. 最长字符串链</a></h4><p>难度中等249收藏分享切换为英文接收动态反馈</p><p>给出一个单词数组 <code>words</code> ，其中每个单词都由小写英文字母组成。</p><p>如果我们可以 <strong>不改变其他字符的顺序</strong> ，在 <code>wordA</code> 的任何地方添加 <strong>恰好一个</strong> 字母使其变成 <code>wordB</code> ，那么我们认为 <code>wordA</code> 是 <code>wordB</code> 的 <strong>前身</strong> 。</p><ul><li>例如，<code>&quot;abc&quot;</code> 是 <code>&quot;abac&quot;</code> 的 <strong>前身</strong> ，而 <code>&quot;cba&quot;</code> 不是 <code>&quot;bcad&quot;</code> 的 <strong>前身</strong></li></ul><p><strong>词链</strong>是单词 <code>[word_1, word_2, ..., word_k]</code> 组成的序列，<code>k &gt;= 1</code>，其中 <code>word1</code> 是 <code>word2</code> 的前身，<code>word2</code> 是 <code>word3</code> 的前身，依此类推。一个单词通常是 <code>k == 1</code> 的 <strong>单词链</strong> 。</p><p>从给定单词列表 <code>words</code> 中选择单词组成词链，返回 词链的 <strong>最长可能长度</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长单词链之一为 [&quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;xbc&quot;,&quot;pcxbcf&quot;,&quot;xb&quot;,&quot;cxbc&quot;,&quot;pcxbc&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：所有的单词都可以放入单词链 [&quot;xb&quot;, &quot;xbc&quot;, &quot;cxbc&quot;, &quot;pcxbc&quot;, &quot;pcxbcf&quot;].</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;abcd&quot;,&quot;dbqca&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：字链[&quot;abcd&quot;]是最长的字链之一。</span><br><span class="line">[&quot;abcd&quot;，&quot;dbqca&quot;]不是一个有效的单词链，因为字母的顺序被改变了。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>动态规划+哈希表</p><p>先按照长度升序排列字符串数组</p><p>然后遍历每一个字符串，对于每一个字符串，以他结尾的最长链长度为x,遍历他所有可能的减去一个字符后的结果t，如果t没出现过那就是0,否则是d[t]。那么x&#x3D;max(x,d[t]+1)。</p><p>让d[s]&#x3D;x,最后维护结果ans&#x3D;max(ans,x)即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(string &amp;a,string &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestStrChain</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>(),cmp);</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; d;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;s:words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                string t=s.<span class="built_in">substr</span>(<span class="number">0</span>,i)+s.<span class="built_in">substr</span>(i+<span class="number">1</span>);</span><br><span class="line">                x=<span class="built_in">max</span>(x,d[t]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            d[s]=x;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-02</title>
      <link href="/2023/04/25/%E5%8A%9B%E6%89%A3hot100-02/"/>
      <url>/2023/04/25/%E5%8A%9B%E6%89%A3hot100-02/</url>
      
        <content type="html"><![CDATA[<h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h4><p>难度中等5895收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p><p>你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针：</p><p>先对数组进行排序</p><p>用i遍历每一个数：</p><p>首先，如果i位置的数等于i+1位置的数，说明这两个数在结果中是等效的，让i+1</p><p>然后，对于每一个i位置的数，右边设置双指针l&#x3D;i+1,r&#x3D;n-1</p><p>不断让l和r向它们的中间移动，其中，当nums[i]+nums[l]+nums[r]&#x3D;0时， 和i一样，如果l位置的数等于l+1位置的数或者r位置的数等于r-1位置的数，则让l++或r–</p><p>如果每次nums[i]+nums[l]+nums[r]大于0 则让r–</p><p>否则让l++即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;<span class="number">0</span>||nums[n<span class="number">-1</span>]&lt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[l]+nums[r]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r<span class="number">-1</span>]) r--;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l+<span class="number">1</span>]) l++;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[l]+nums[r]&gt;<span class="number">0</span>) r--;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[l]+nums[r]&lt;<span class="number">0</span>) l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣hot100-01</title>
      <link href="/2023/04/24/%E5%8A%9B%E6%89%A3hot100-01/"/>
      <url>/2023/04/24/%E5%8A%9B%E6%89%A3hot100-01/</url>
      
        <content type="html"><![CDATA[<h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong>你不能倾斜容器。</p><p><strong>示例 1：</strong></p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针，初始i指向最左边，j指向最右边，让i和j往中间移动</p><p>当i指向的高度小于j时，让i右移</p><p>否则j左移</p><p>维护一个res，不断存储这期间的最大值</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,<span class="built_in">min</span>(height[i],height[j])*(j-i));</span><br><span class="line">            <span class="keyword">if</span>(height[i]&lt;height[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣hot100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题28</title>
      <link href="/2023/04/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9828/"/>
      <url>/2023/04/24/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9828/</url>
      
        <content type="html"><![CDATA[<h4 id="1163-按字典序排在最后的子串"><a href="#1163-按字典序排在最后的子串" class="headerlink" title="1163. 按字典序排在最后的子串"></a><a href="https://leetcode.cn/problems/last-substring-in-lexicographical-order/">1163. 按字典序排在最后的子串</a></h4><p>难度困难108收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>s</code> ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abab&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：我们可以找出 7 个子串 [&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abab&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bab&quot;]。按字典序排在最后的子串是 &quot;bab&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;tcode&quot;</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>双指针：</p><p>i指向最大字典序后缀串的第一个字符</p><p>j指向比较的后缀串的第一个字符</p><p>k用来比较</p><p>初始i&#x3D;0，j&#x3D;1,k&#x3D;0</p><p>每次比较s[i+k]和s[j+k]</p><p>如果s[i+k]&#x3D;s[j+k]：说明s[i,..i+k]和s[j,…j+k]可以等效，继续比较即可。k++</p><p>如果s[i+k]&lt;s[j+k]：说明s[i,…i+k]不可以当首字符，让i&#x3D;i+k+1，如果此时i&gt;&#x3D;j，那就让j&#x3D;i+1（保证两个指针的顺序）。同时清零k，继续比较。</p><p>如果s[i+k]&gt;s[j+k]：说明s[i…i+k]要当首字符，而s[j,…j+k]不可以，跳过这些，让j&#x3D;j+k+1，同时清零k，继续比较。</p><p>最后返回以i为首字符的后缀子串即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">lastSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,k=<span class="number">0</span>;j+k&lt;n;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+k]==s[j+k])</span><br><span class="line">            &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i+k]&lt;s[j+k])</span><br><span class="line">            &#123;</span><br><span class="line">                i=i+k+<span class="number">1</span>;</span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">                &#123;</span><br><span class="line">                    j=i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j=j+k+<span class="number">1</span>;</span><br><span class="line">                k=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题27</title>
      <link href="/2023/04/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9827/"/>
      <url>/2023/04/22/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9827/</url>
      
        <content type="html"><![CDATA[<h4 id="1027-最长等差数列"><a href="#1027-最长等差数列" class="headerlink" title="1027. 最长等差数列"></a><a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/">1027. 最长等差数列</a></h4><p>难度中等291收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code>，返回 <code>nums</code> 中最长等差子序列的<strong>长度</strong>。</p><p>回想一下，<code>nums</code> 的子序列是一个列表 <code>nums[i1], nums[i2], ..., nums[ik]</code> ，且 <code>0 &lt;= i1 &lt; i2 &lt; ... &lt; ik &lt;= nums.length - 1</code>。并且如果 <code>seq[i+1] - seq[i]</code>( <code>0 &lt;= i &lt; seq.length - 1</code>) 的值都相同，那么序列 <code>seq</code> 是等差的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,6,9,12]</span><br><span class="line">输出：4</span><br><span class="line">解释： </span><br><span class="line">整个数组是公差为 3 的等差数列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,4,7,2,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">最长的等差子序列是 [4,7,10]。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [20,1,15,3,10,5,8]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最长的等差子序列是 [20,15,10,5]。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>dp[i] [j]代表以第i个元素为结尾，差为j的数组的长度。</p><p>k是i之前的元素</p><p>递推式：dp[i] [j]&#x3D;max(dp[i] [j],dp[k] [j]+1)</p><p>防止差为负数：给每个差都加500（上限）</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestArithSeqLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[n+<span class="number">1</span>][<span class="number">1001</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> te=nums[i]-nums[j]+<span class="number">500</span>;</span><br><span class="line">                dp[i][te]=<span class="built_in">max</span>(dp[i][te],dp[j][te]+<span class="number">1</span>);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans,dp[i][te]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题26</title>
      <link href="/2023/04/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9826/"/>
      <url>/2023/04/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9826/</url>
      
        <content type="html"><![CDATA[<h4 id="1026-节点与其祖先之间的最大差值"><a href="#1026-节点与其祖先之间的最大差值" class="headerlink" title="1026. 节点与其祖先之间的最大差值"></a><a href="https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/">1026. 节点与其祖先之间的最大差值</a></h4><p>给定二叉树的根节点 <code>root</code>，找出存在于 <strong>不同</strong> 节点 <code>A</code> 和 <code>B</code> 之间的最大值 <code>V</code>，其中 <code>V = |A.val - B.val|</code>，且 <code>A</code> 是 <code>B</code> 的祖先。</p><p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]</span><br><span class="line">输出：7</span><br><span class="line">解释： </span><br><span class="line">我们有大量的节点与其祖先的差值，其中一些如下：</span><br><span class="line">|8 - 3| = 5</span><br><span class="line">|3 - 7| = 4</span><br><span class="line">|8 - 1| = 7</span><br><span class="line">|10 - 13| = 3</span><br><span class="line">在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,null,0,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>每次遍历到一个节点时，存储它的所有祖先节点的最大值和最小值，将max-root-&gt;val的绝对值和min-root-&gt;val的绝对值取大的那一个和之前的结果res比较即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res=<span class="built_in">max</span>(res,<span class="built_in">max</span>(<span class="built_in">abs</span>(val1-root-&gt;val),<span class="built_in">abs</span>(val2-root-&gt;val)));</span><br><span class="line"></span><br><span class="line">        val1=<span class="built_in">min</span>(val1,root-&gt;val);</span><br><span class="line">        val2=<span class="built_in">max</span>(val2,root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,val1,val2);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,val1,val2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root,root-&gt;val,root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遍历二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题25</title>
      <link href="/2023/04/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9825/"/>
      <url>/2023/04/18/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9825/</url>
      
        <content type="html"><![CDATA[<h4 id="1041-困于环中的机器人"><a href="#1041-困于环中的机器人" class="headerlink" title="1041. 困于环中的机器人"></a><a href="https://leetcode.cn/problems/robot-bounded-in-circle/">1041. 困于环中的机器人</a></h4><p>在无限的平面上，机器人最初位于 <code>(0, 0)</code> 处，面朝北方。注意:</p><ul><li><strong>北方向</strong> 是y轴的正方向。</li><li><strong>南方向</strong> 是y轴的负方向。</li><li><strong>东方向</strong> 是x轴的正方向。</li><li><strong>西方向</strong> 是x轴的负方向。</li></ul><p>机器人可以接受下列三条指令之一：</p><ul><li><code>&quot;G&quot;</code>：直走 1 个单位</li><li><code>&quot;L&quot;</code>：左转 90 度</li><li><code>&quot;R&quot;</code>：右转 90 度</li></ul><p>机器人按顺序执行指令 <code>instructions</code>，并一直重复它们。</p><p>只有在平面中存在环使得机器人永远无法离开时，返回 <code>true</code>。否则，返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：instructions = &quot;GGLLGG&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：机器人最初在(0,0)处，面向北方。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:北。</span><br><span class="line">“G”:移动一步。位置:(0,2).方向:北。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,2).方向:西。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,2)方向:南。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:南。</span><br><span class="line">“G”:移动一步。位置:(0,0)方向:南。</span><br><span class="line">重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(0,2)——&gt;(0,1)——&gt;(0,0)。</span><br><span class="line">在此基础上，我们返回true。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：instructions = &quot;GG&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：机器人最初在(0,0)处，面向北方。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:北。</span><br><span class="line">“G”:移动一步。位置:(0,2).方向:北。</span><br><span class="line">重复这些指示，继续朝北前进，不会进入循环。</span><br><span class="line">在此基础上，返回false。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：instructions = &quot;GL&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：机器人最初在(0,0)处，面向北方。</span><br><span class="line">“G”:移动一步。位置:(0,1)方向:北。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,1).方向:西。</span><br><span class="line">“G”:移动一步。位置:(- 1,1)方向:西。</span><br><span class="line">“L”:逆时针旋转90度。位置:(- 1,1)方向:南。</span><br><span class="line">“G”:移动一步。位置:(- 1,0)方向:南。</span><br><span class="line">“L”:逆时针旋转90度。位置:(- 1,0)方向:东方。</span><br><span class="line">“G”:移动一步。位置:(0,0)方向:东方。</span><br><span class="line">“L”:逆时针旋转90度。位置:(0,0)方向:北。</span><br><span class="line">重复指令，机器人进入循环:(0,0)——&gt;(0,1)——&gt;(- 1,1)——&gt;(- 1,0)——&gt;(0,0)。</span><br><span class="line">在此基础上，我们返回true。</span><br></pre></td></tr></table></figure><p> <strong>思路：</strong></p><p>当机器人执行完指令<br>instructions后，它的位置和方向均有可能发生变化。</p><p>如果它的位置仍位于原点，那么不管它此时方向是什么，机器人都将永远无法离开。</p><p>如果它的位置不在原点，那么需要考虑此时机器人的方向：</p><p>如果机器人仍然朝北，那么机器人可以不会陷入循环。假设执行完一串指令后，机器人的位置是 (x,y) 且不为原点，方向仍然朝北，那么执行完第二串指令后，机器人的位置便成为 (2×x,2×y)，会不停地往外部移动，不会陷入循环。<br>如果机器人朝南，那么执行第二串指令时，机器人的位移会与第一次相反，即第二次的位移是 (−x,−y)，并且结束后会回到原来的方向。这样一来，每两串指令之后，机器人都会回到原点，并且方向朝北，机器人会陷入循环。<br>如果机器人朝东，即右转了 90°。这样一来，每执行一串指令，机器人都会右转 90°。那么第一次和第三次指令的方向是相反的，第二次和第四次指令的方向是相反的，位移之和也为 0，这样一来，每四次指令之后，机器人都会回到原点，并且方向朝北，机器人会陷入循环。如果机器人朝西，也是一样的结果。<br>因此，机器人想要摆脱循环，在一串指令之后的状态，必须是不位于原点且方向朝北。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRobotBounded</span><span class="params">(string instructions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> direction=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:instructions)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(direction==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    y+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    x-=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(direction==<span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    y-=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    x+=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                direction=(direction+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                direction=(direction+<span class="number">3</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((x||y)&amp;&amp;direction==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题24</title>
      <link href="/2023/04/16/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9824/"/>
      <url>/2023/04/16/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9824/</url>
      
        <content type="html"><![CDATA[<h4 id="1019-链表中的下一个更大节点"><a href="#1019-链表中的下一个更大节点" class="headerlink" title="1019. 链表中的下一个更大节点"></a><a href="https://leetcode.cn/problems/next-greater-node-in-linked-list/">1019. 链表中的下一个更大节点</a></h4><p>给定一个长度为 <code>n</code> 的链表 <code>head</code></p><p>对于列表中的每个节点，查找下一个 <strong>更大节点</strong> 的值。也就是说，对于每个节点，找到它旁边的第一个节点的值，这个节点的值 <strong>严格大于</strong> 它的值。</p><p>返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点( <strong>从1开始</strong> )的下一个更大的节点的值。如果第 <code>i</code> 个节点没有下一个更大的节点，设置 <code>answer[i] = 0</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [2,1,5]</span><br><span class="line">输出：[5,5,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [2,7,4,3,5]</span><br><span class="line">输出：[7,0,5,5,0]</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>单调栈：</p><p>用一个栈的栈顶元素存储当前数右边最大的点，当有点比栈顶元素大的时候，就把栈顶元素pop掉</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextLargerNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n=v.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;s.<span class="built_in">top</span>()&lt;=v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res[i]=s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(v[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/10/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%EF%BC%88%E5%8F%AF%E7%94%A8%E4%BD%9C%E8%AE%B2%E7%A8%BF%EF%BC%89/"/>
      <url>/2023/04/10/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%EF%BC%88%E5%8F%AF%E7%94%A8%E4%BD%9C%E8%AE%B2%E7%A8%BF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>ChatGPT：列举常见的聚类算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. K-Means聚类算法</span><br><span class="line">2. 层次聚类算法</span><br><span class="line">3. DBSCAN聚类算法</span><br><span class="line">4. GMM聚类算法</span><br><span class="line">5. 密度聚类算法（比如OPTICS）</span><br></pre></td></tr></table></figure><p>ChatGPT：“DNN聚类算法”相比于“基于相似度矩阵的聚类算法”，“K-Means聚类算法”，“密度聚类算法”，“层次聚类算法”有什么优点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DNN（Deep Neural Network）聚类算法相比基于相似度矩阵的聚类算法、K-Means聚类算法、密度聚类算法、层次聚类算法有如下优点：</span><br><span class="line"></span><br><span class="line">1. 自适应特征提取：DNN聚类算法在进行聚类的过程中，可以自适应提取具有不同抽象层次的特征，相较于基于相似度矩阵的聚类算法、K-Means聚类算法、密度聚类算法、层次聚类算法更具表达能力。</span><br><span class="line"></span><br><span class="line">2. 高维数据处理：DNN聚类算法能够处理高维数据，在处理大规模高维数据时具有优势，相较于K-Means聚类算法和层次聚类算法更具优势。</span><br><span class="line"></span><br><span class="line">3. 鲁棒性高：DNN聚类算法的优化过程相对于K-Means聚类算法、密度聚类算法、层次聚类算法更为稳定，对于噪声和异常点具有一定的鲁棒性。</span><br><span class="line"></span><br><span class="line">4. 可解释性好：DNN聚类算法的层级结构可以被理解为对数据的分层聚类，因此其聚类结果可以被更好地解释和理解。</span><br><span class="line"></span><br><span class="line">但是，DNN聚类算法的计算复杂度较高，需要进行大量的训练，也需要较大的计算资源，相较于一些传统的聚类算法，如K-Means聚类算法和层次聚类算法，会在计算效率方面存在一定的劣势。</span><br></pre></td></tr></table></figure><p>ChatGPT：“基于相似度矩阵的聚类算法”，“K-Means聚类算法”，“密度聚类算法”，“层次聚类算法”相较于“DNN聚类算法”各有什么缺点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">相较于DNN聚类算法，基于相似度矩阵的聚类算法、K-Means聚类算法、密度聚类算法、层次聚类算法各自存在一些缺点：</span><br><span class="line"></span><br><span class="line">1. 基于相似度矩阵的聚类算法：</span><br><span class="line">（1）对于大规模数据集，相似度矩阵的计算量较大；</span><br><span class="line">（2）相似度矩阵通常需要事先计算出来，比较耗时；</span><br><span class="line">（3）算法对噪声和离群点比较敏感。</span><br><span class="line"></span><br><span class="line">2. K-Means聚类算法：</span><br><span class="line">（1）需要明确指定聚类数量，否则难以得到好的聚类效果；</span><br><span class="line">（2）对初始聚类中心敏感，初始聚类中心对最终聚类效果有很大影响；</span><br><span class="line">（3）只适用于凸数据集，对噪声和离群点比较敏感。</span><br><span class="line"></span><br><span class="line">3. 密度聚类算法：</span><br><span class="line">（1）对数据分布的密度要求比较高，数据集中密度差异较大时容易产生问题；</span><br><span class="line">（2）对数据参数的敏感度较高。</span><br><span class="line"></span><br><span class="line">4. 层次聚类算法：</span><br><span class="line">（1）时间复杂度较高，在处理大数据集时不适用；</span><br><span class="line">（2）不适用于处理噪声和离群点。</span><br><span class="line"></span><br><span class="line">DNN聚类算法由于优秀的表达能力和自适应学习能力，因此在处理高维、非线性、非凸等数据时具备更加优秀的性能。</span><br></pre></td></tr></table></figure><p>参考论文：《基于深度学习的威胁情报信息抽取研究》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传统的基于统计的方法需要进行大量的特征工程，耗时费力，且训练得到的模型只针对特定领域，难以在其他领域复用，而基于深度学习的方法减少了对特征工程的需求，预处理和训练成本更低，具有一定的应用价值。在将来的研究工作中，可以继续研究语料库自动标注算法，并提高神经网络模型精度，实现威胁情报信息的自动化抽取方法，供网络安全从业人员使用。</span><br></pre></td></tr></table></figure><p>参考博客：图神经网络时代的深度聚类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/114452245</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/04/07/%E4%BF%A1%E5%AE%89%E8%B5%9B%E7%AE%97%E6%B3%95%E6%83%B3%E6%B3%95/"/>
      <url>/2023/04/07/%E4%BF%A1%E5%AE%89%E8%B5%9B%E7%AE%97%E6%B3%95%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>聚类算法：</p><p>①按照第一层聚类</p><p>②将第一层聚类后的各个簇作为一个实体，继承其子实体的所有属性。</p><p>③计算这些实体之间的相似度矩阵，或者多算点东西（看着高级点）</p><p>（4.8加）A对B之间的相似度向量—–&gt;A和B之间的距离（保证A和B之间的距离等于B到A之间的距离，之前计算分数是分别除以各自长度，要保证的话就要除以两个加起来的总长）</p><p>（4.8加）假如已知实体之间的“距离”，最简单的方法就是k-means或者层次聚类法HAC。神经网络有2点想不通：a）输出的是两两之间的相似概率，如果是监督学习，这方面数据基本不能确定。b）如果是非监督学习，就是PCA？自编码器是输入既作为输入也作为监督，得到隐藏层，再通过解码器进行解码，也不太知道咋么用。</p><p>④（RNN应该行不通）用训练集训练一个DNN，对相似度矩阵每一维度进行概率预测。</p><p>⑤对于每一个实体，如果和另一个实体的相似概率高于一个阈值，就将其中的cover聚为一类，有多个高于阈值的（取最高？还是都聚为一类）</p><p>身份判定算法：</p><p>使用公司数据，统计四种身份对每种攻击方式的偏好度。 </p><p>① 为各属性加标签，比如可以研判一个域名是黑帽子属性的，为其前缀加上黑帽子标签。（或者是概率分布，就比如黑帽子40%，其余20%那标签就是{黑帽子，黑帽子，白帽子，安全…，爬虫..或者其他关键词}（叫词素模型，或者什么的）来训练CBOW</p><p>②确定各身份的关键词库</p><p>③用CBOW词袋模型结合标签，对每个切片进行词频统计。各关键词的出现频率求身份概率….</p><p>IP sdate cookie xff </p><p>A-》B  </p><p>【0,1,2,3】</p><p>【2,3,4,5】</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题23</title>
      <link href="/2023/04/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9823/"/>
      <url>/2023/04/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9823/</url>
      
        <content type="html"><![CDATA[<h4 id="1017-负二进制转换"><a href="#1017-负二进制转换" class="headerlink" title="1017. 负二进制转换"></a><a href="https://leetcode.cn/problems/convert-to-base-2/">1017. 负二进制转换</a></h4><p>给你一个整数 <code>n</code> ，以二进制字符串的形式返回该整数的 <strong>负二进制（<code>base -2</code>）</strong>表示。</p><p><strong>注意，</strong>除非字符串就是 <code>&quot;0&quot;</code>，否则返回的字符串中不能含有前导零。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：&quot;110&quot;</span><br><span class="line">解释：(-2)2 + (-2)1 = 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：&quot;111&quot;</span><br><span class="line">解释：(-2)2 + (-2)1 + (-2)0 = 3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：&quot;100&quot;</span><br><span class="line">解释：(-2)2 = 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 109</code></li></ul><p><strong>思路：</strong></p><p>负数为底的进制转换：</p><p>n十进制数</p><p>n%底 取绝对值 加入结果的末尾</p><p>n-（n%底的绝对值）再除以底</p><p>循环直到n为0</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">baseNeg2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c=<span class="built_in">abs</span>(n%<span class="number">-2</span>);</span><br><span class="line">            res=(c==<span class="number">1</span>?<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;0&#x27;</span>)+res;</span><br><span class="line">            n=(n-c)/(<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题22</title>
      <link href="/2023/03/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9822/"/>
      <url>/2023/03/30/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9822/</url>
      
        <content type="html"><![CDATA[<h4 id="1053-交换一次的先前排列"><a href="#1053-交换一次的先前排列" class="headerlink" title="1053. 交换一次的先前排列"></a><a href="https://leetcode.cn/problems/previous-permutation-with-one-swap/">1053. 交换一次的先前排列</a></h4><p>给你一个正整数数组 <code>arr</code>（可能存在重复的元素），请你返回可在 <strong>一次交换</strong>（交换两数字 <code>arr[i]</code> 和 <code>arr[j]</code> 的位置）后得到的、按字典序排列小于 <code>arr</code> 的最大排列。</p><p>如果无法这么操作，就请返回原数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1]</span><br><span class="line">输出：[3,1,2]</span><br><span class="line">解释：交换 2 和 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,1,5]</span><br><span class="line">输出：[1,1,5]</span><br><span class="line">解释：已经是最小排列</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,9,4,6,7]</span><br><span class="line">输出：[1,7,4,6,9]</span><br><span class="line">解释：交换 9 和 7</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>第一步：从当前序列的后往前找，找到第一个降序的位置（A[i]&gt;A[i+1]），则必存在能构造比当前小的序列。</p><p>第二步：把A[i]后面的数字中，小于A[i]且最接近A[i]的值的数字找出来，和A[i]交换。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-1</span>]&gt;arr[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i<span class="number">-1</span>;j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]&lt;arr[i<span class="number">-1</span>]&amp;&amp;arr[j]!=arr[j<span class="number">-1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">swap</span>(arr[i<span class="number">-1</span>],arr[j]);</span><br><span class="line">                        <span class="keyword">return</span> arr;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题21</title>
      <link href="/2023/03/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9821/"/>
      <url>/2023/03/29/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9821/</url>
      
        <content type="html"><![CDATA[<h4 id="1641-统计字典序元音字符串的数目"><a href="#1641-统计字典序元音字符串的数目" class="headerlink" title="1641. 统计字典序元音字符串的数目"></a><a href="https://leetcode.cn/problems/count-sorted-vowel-strings/">1641. 统计字典序元音字符串的数目</a></h4><p>给你一个整数 <code>n</code>，请返回长度为 <code>n</code> 、仅由元音 (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) 组成且按 <strong>字典序排列</strong> 的字符串数量。</p><p>字符串 <code>s</code> 按 <strong>字典序排列</strong> 需要满足：对于所有有效的 <code>i</code>，<code>s[i]</code> 在字母表中的位置总是与 <code>s[i+1]</code> 相同或在 <code>s[i+1]</code> 之前。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：5</span><br><span class="line">解释：仅由元音组成的 5 个字典序字符串为 [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：15</span><br><span class="line">解释：仅由元音组成的 15 个字典序字符串为</span><br><span class="line">[&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;]</span><br><span class="line">注意，&quot;ea&quot; 不是符合题意的字符串，因为 &#x27;e&#x27; 在字母表中的位置比 &#x27;a&#x27; 靠后</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 33</span><br><span class="line">输出：66045</span><br></pre></td></tr></table></figure><p><strong>思路：（动态规划）</strong></p><p>dp[i] [j]表示i长度时以j结尾的所有字符串,有如下递推式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">3</span>]=dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">4</span>]=dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countVowelStrings</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> dp[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">2</span>]+dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">3</span>]=dp[i<span class="number">-1</span>][<span class="number">3</span>]+dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">4</span>]=dp[i<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>]+dp[n][<span class="number">1</span>]+dp[n][<span class="number">2</span>]+dp[n][<span class="number">3</span>]+dp[n][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题20</title>
      <link href="/2023/03/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9820/"/>
      <url>/2023/03/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9820/</url>
      
        <content type="html"><![CDATA[<h4 id="1092-最短公共超序列"><a href="#1092-最短公共超序列" class="headerlink" title="1092. 最短公共超序列"></a><a href="https://leetcode.cn/problems/shortest-common-supersequence/">1092. 最短公共超序列</a></h4><p>给出两个字符串 <code>str1</code> 和 <code>str2</code>，返回同时以 <code>str1</code> 和 <code>str2</code> 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。</p><p>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 <strong>任意位置</strong>），可以得到字符串 S，那么 S 就是 T 的子序列）</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = &quot;abac&quot;, str2 = &quot;cab&quot;</span><br><span class="line">输出：&quot;cabac&quot;</span><br><span class="line">解释：</span><br><span class="line">str1 = &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。 </span><br><span class="line">str2 = &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。</span><br><span class="line">最终我们给出的答案是满足上述属性的最短字符串。</span><br></pre></td></tr></table></figure><p><strong>思路（动态规划+构造）：</strong></p><p>首先求出dp[i] [j]代表str1前i位和str2前j位的最长公共子序列</p><p>dp[i] [j]&#x3D;dp[i-1] [j-1]+1  str1[i]&#x3D;&#x3D;str2[j]</p><p>​&#x3D;max(dp[i-1] [j],dp[i] [j-1]) str1[i]!&#x3D;str2[j]</p><p>然后用双指针i，j分别指向两个字符的末端</p><p>① 当str1[i]&#x3D;&#x3D;str2[j]时 任选一个加入res，然后i和j都减1</p><p>②当str1[i]!&#x3D;str2[j]时，如果dp[i] [j]&#x3D;&#x3D;dp[i-1] [j]那么把str1[i]加入res，i减1</p><p>​dp[i] [j]&#x3D;&#x3D;dp[i] [j-1]那么把str2[j]加入res,j减1</p><p>直到i&#x3D;&#x3D;0或者j&#x3D;&#x3D;0 最后把没有到0的剩下部分全部加入res中，并倒置res</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shortestCommonSupersequence</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=str1.<span class="built_in">size</span>(),m=str2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i<span class="number">-1</span>]==str2[j<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> i=n,j=m;</span><br><span class="line">        <span class="keyword">while</span>(i||j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>) res+=str2[--j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) res+=str1[--i];</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] == dp[i - <span class="number">1</span>][j])</span><br><span class="line">                    res += str1[--i];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j] == dp[i][j - <span class="number">1</span>])</span><br><span class="line">                    res += str2[--j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    res += str1[--i], --j;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题19</title>
      <link href="/2023/03/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9819/"/>
      <url>/2023/03/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9819/</url>
      
        <content type="html"><![CDATA[<h4 id="1638-统计只差一个字符的子串数目"><a href="#1638-统计只差一个字符的子串数目" class="headerlink" title="1638. 统计只差一个字符的子串数目"></a><a href="https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/">1638. 统计只差一个字符的子串数目</a></h4><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，请你找出 <code>s</code> 中的非空子串的数目，这些子串满足替换 <strong>一个不同字符</strong> 以后，是 <code>t</code> 串的子串。换言之，请你找到 <code>s</code> 和 <code>t</code> 串中 <strong>恰好</strong> 只有一个字符不同的子字符串对的数目。</p><p>比方说， <code>&quot;computer&quot;</code> and <code>&quot;computation&quot; </code>只有一个字符不同： <code>&#39;e&#39;</code>&#x2F;<code>&#39;a&#39;</code> ，所以这一对子字符串会给答案加 1 。</p><p>请你返回满足上述条件的不同子字符串对数目。</p><p>一个 <strong>子字符串</strong> 是一个字符串中连续的字符。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aba&quot;, t = &quot;baba&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：</span><br><span class="line">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class="line">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class="line">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class="line">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class="line">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class="line">(&quot;aba&quot;, &quot;baba&quot;)</span><br><span class="line">加粗部分分别表示 s 和 t 串选出来的子字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;, t = &quot;bb&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：</span><br><span class="line">(&quot;ab&quot;, &quot;bb&quot;)</span><br><span class="line">(&quot;ab&quot;, &quot;bb&quot;)</span><br><span class="line">(&quot;ab&quot;, &quot;bb&quot;)</span><br><span class="line">加粗部分分别表示 s 和 t 串选出来的子字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abe&quot;, t = &quot;bbc&quot;</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>动态规划 dp【i】【j】表示s[i]与t[j]为最后一个字符时前面的差距一个的子字符串</p><p>same【i】【j】表示s[i]与t[j]为最后一个字符时的相同的子字符串</p><p>所以递推关系：</p><p>s[i]&#x3D;&#x3D;t[j] dp[i+1] [j+1]&#x3D;dp[i] [j]</p><p>​same[i+1] [j+1]&#x3D;same[i] [j]+1</p><p>s[i]!&#x3D;t[j] dp[i+1] [j+1]&#x3D;same[i] [j]+1</p><p>​same[i+1] [j+1]&#x3D;0</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>(),m=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>]=&#123;&#125;,same[<span class="number">101</span>][<span class="number">101</span>]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==t[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">                    same[i+<span class="number">1</span>][j+<span class="number">1</span>]=same[i][j]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=same[i][j]+<span class="number">1</span>;</span><br><span class="line">                    same[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res+=dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题18</title>
      <link href="/2023/03/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9818/"/>
      <url>/2023/03/26/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9818/</url>
      
        <content type="html"><![CDATA[<h4 id="1574-删除最短的子数组使剩余数组有序"><a href="#1574-删除最短的子数组使剩余数组有序" class="headerlink" title="1574. 删除最短的子数组使剩余数组有序"></a><a href="https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/">1574. 删除最短的子数组使剩余数组有序</a></h4><p>给你一个整数数组 <code>arr</code> ，请你删除一个子数组（可以为空），使得 <code>arr</code> 中剩下的元素是 <strong>非递减</strong> 的。</p><p>一个子数组指的是原数组中连续的一个子序列。</p><p>请你返回满足题目要求的最短子数组的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,2,3,10,4,2,3,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。</span><br><span class="line">另一个正确的解为删除子数组 [3,10,4] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [5,4,3,2,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1,2,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组已经是非递减的了，我们不需要删除任何元素。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>先从前往后找到前缀的最大非递减数列[0,1…i]，再从后往前找后缀的最大非递减数列[j,…n-1]</p><p>首先ans取删除其余部分的最小值ans&#x3D;min(j,n-1-i)</p><p>然后如果是删除中间部分可以使用二分或者双指针，对于每一个前缀中的下标l，在后缀中找到第一个大于arr[l]的数的下标r</p><p>ans&#x3D;min(ans,r-l-1)</p><p><strong>代码（二分）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfShortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n=arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;n<span class="number">-1</span>&amp;&amp;arr[i]&lt;=arr[i+<span class="number">1</span>]) i++;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span>&amp;&amp;arr[j<span class="number">-1</span>]&lt;=arr[j]) j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans=<span class="built_in">min</span>(j,n<span class="number">-1</span>-i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=i;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=<span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>()+j,arr.<span class="built_in">end</span>(),arr[l])-arr.<span class="built_in">begin</span>();</span><br><span class="line">            ans=<span class="built_in">min</span>(ans,r-l<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码（双指针）：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfShortestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span> &lt; n &amp;&amp; arr[i] &lt;= arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &lt;= arr[j]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">min</span>(n - <span class="number">1</span> - i, j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = j; l &lt;= i; ++l) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; arr[r] &lt; arr[l]) &#123;</span><br><span class="line">                ++r;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, r - l - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题17</title>
      <link href="/2023/03/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9817/"/>
      <url>/2023/03/15/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9817/</url>
      
        <content type="html"><![CDATA[<h4 id="1615-最大网络秩"><a href="#1615-最大网络秩" class="headerlink" title="1615. 最大网络秩"></a><a href="https://leetcode.cn/problems/maximal-network-rank/">1615. 最大网络秩</a></h4><p><code>n</code> 座城市和一些连接这些城市的道路 <code>roads</code> 共同组成一个基础设施网络。每个 <code>roads[i] = [ai, bi]</code> 都表示在城市 <code>ai</code> 和 <code>bi</code> 之间有一条双向道路。</p><p>两座不同城市构成的 <strong>城市对</strong> 的 <strong>网络秩</strong> 定义为：与这两座城市 <strong>直接</strong> 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 <strong>一次</strong> 。</p><p>整个基础设施网络的 <strong>最大网络秩</strong> 是所有不同城市对中的 <strong>最大网络秩</strong> 。</p><p>给你整数 <code>n</code> 和数组 <code>roads</code>，返回整个基础设施网络的 <strong>最大网络秩</strong> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]</span><br><span class="line">输出：4</span><br><span class="line">解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]</span><br><span class="line">输出：5</span><br><span class="line">解释：共有 5 条道路与城市 1 或 2 相连。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 8, roads = [[0,1],[1,2],[2,3],[2,4],[5,6],[5,7]]</span><br><span class="line">输出：5</span><br><span class="line">解释：2 和 5 的网络秩为 5，注意并非所有的城市都需要连接起来。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= roads.length &lt;= n * (n - 1) / 2</code></li><li><code>roads[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt;= n-1</code></li><li><code>ai != bi</code></li><li>每对城市之间 <strong>最多只有一条</strong> 道路相连</li></ul><p><strong>思路：</strong></p><p>暴力模拟</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; zhi;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">path</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:roads)</span><br><span class="line">        &#123;</span><br><span class="line">            zhi[t[<span class="number">0</span>]]++;</span><br><span class="line">            zhi[t[<span class="number">1</span>]]++;</span><br><span class="line">            path[t[<span class="number">0</span>]][t[<span class="number">1</span>]]=<span class="number">-1</span>;</span><br><span class="line">            path[t[<span class="number">1</span>]][t[<span class="number">0</span>]]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> t=zhi[i]+zhi[j]+path[i][j];</span><br><span class="line">                res=<span class="built_in">max</span>(res,t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题16</title>
      <link href="/2023/03/14/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9816/"/>
      <url>/2023/03/14/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9816/</url>
      
        <content type="html"><![CDATA[<h4 id="1605-给定行和列的和求可行矩阵"><a href="#1605-给定行和列的和求可行矩阵" class="headerlink" title="1605. 给定行和列的和求可行矩阵"></a><a href="https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/">1605. 给定行和列的和求可行矩阵</a></h4><p>给你两个非负整数数组 <code>rowSum</code> 和 <code>colSum</code> ，其中 <code>rowSum[i]</code> 是二维矩阵中第 <code>i</code> 行元素的和， <code>colSum[j]</code> 是第 <code>j</code> 列元素的和。换言之你不知道矩阵里的每个元素，但是你知道每一行和每一列的和。</p><p>请找到大小为 <code>rowSum.length x colSum.length</code> 的任意 <strong>非负整数</strong> 矩阵，且该矩阵满足 <code>rowSum</code> 和 <code>colSum</code> 的要求。</p><p>请你返回任意一个满足题目要求的二维矩阵，题目保证存在 <strong>至少一个</strong> 可行矩阵。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：rowSum = [3,8], colSum = [4,7]</span><br><span class="line">输出：[[3,0],</span><br><span class="line">      [1,7]]</span><br><span class="line">解释：</span><br><span class="line">第 0 行：3 + 0 = 3 == rowSum[0]</span><br><span class="line">第 1 行：1 + 7 = 8 == rowSum[1]</span><br><span class="line">第 0 列：3 + 1 = 4 == colSum[0]</span><br><span class="line">第 1 列：0 + 7 = 7 == colSum[1]</span><br><span class="line">行和列的和都满足题目要求，且所有矩阵元素都是非负的。</span><br><span class="line">另一个可行的矩阵为：[[1,2],</span><br><span class="line">                  [3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rowSum = [5,7,10], colSum = [8,6,8]</span><br><span class="line">输出：[[0,5,0],</span><br><span class="line">      [6,1,0],</span><br><span class="line">      [2,0,8]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rowSum = [14,9], colSum = [6,9,8]</span><br><span class="line">输出：[[0,9,5],</span><br><span class="line">      [6,0,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rowSum = [1,0], colSum = [1]</span><br><span class="line">输出：[[1],</span><br><span class="line">      [0]]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rowSum = [0], colSum = [0]</span><br><span class="line">输出：[[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= rowSum.length, colSum.length &lt;= 500</code></li><li><code>0 &lt;= rowSum[i], colSum[i] &lt;= 108</code></li><li><code>sum(rowSum) == sum(colSum)</code></li></ul><p><strong>思路（贪心）：</strong></p><p>对于res矩阵的第i，j位，取对应rowsum和colsum的最小值，然后让对应的rowsum和colsum同时减去res[i,j]，这样遍历矩阵的所有格子，就会得到符合条件的矩阵。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">restoreMatrix</span>(vector&lt;<span class="type">int</span>&gt;&amp; rowSum, vector&lt;<span class="type">int</span>&gt;&amp; colSum) &#123;</span><br><span class="line">        <span class="type">int</span> n=rowSum.<span class="built_in">size</span>(),m=colSum.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i][j]=<span class="built_in">min</span>(rowSum[i],colSum[j]);</span><br><span class="line">                rowSum[i]-=res[i][j];</span><br><span class="line">                colSum[j]-=res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题15</title>
      <link href="/2023/03/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9815/"/>
      <url>/2023/03/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9815/</url>
      
        <content type="html"><![CDATA[<h4 id="2383-赢得比赛需要的最少训练时长"><a href="#2383-赢得比赛需要的最少训练时长" class="headerlink" title="2383. 赢得比赛需要的最少训练时长"></a><a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/">2383. 赢得比赛需要的最少训练时长</a></h4><p>你正在参加一场比赛，给你两个 <strong>正</strong> 整数 <code>initialEnergy</code> 和 <code>initialExperience</code> 分别表示你的初始精力和初始经验。</p><p>另给你两个下标从 <strong>0</strong> 开始的整数数组 <code>energy</code> 和 <code>experience</code>，长度均为 <code>n</code> 。</p><p>你将会 <strong>依次</strong> 对上 <code>n</code> 个对手。第 <code>i</code> 个对手的精力和经验分别用 <code>energy[i]</code> 和 <code>experience[i]</code> 表示。当你对上对手时，需要在经验和精力上都 <strong>严格</strong> 超过对手才能击败他们，然后在可能的情况下继续对上下一个对手。</p><p>击败第 <code>i</code> 个对手会使你的经验 <strong>增加</strong> <code>experience[i]</code>，但会将你的精力 <strong>减少</strong> <code>energy[i]</code> 。</p><p>在开始比赛前，你可以训练几个小时。每训练一个小时，你可以选择将增加经验增加 1 <strong>或者</strong> 将精力增加 1 。</p><p>返回击败全部 <code>n</code> 个对手需要训练的 <strong>最少</strong> 小时数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：在 6 小时训练后，你可以将精力提高到 11 ，并且再训练 2 个小时将经验提高到 5 。</span><br><span class="line">按以下顺序与对手比赛：</span><br><span class="line">- 你的精力与经验都超过第 0 个对手，所以获胜。</span><br><span class="line">  精力变为：11 - 1 = 10 ，经验变为：5 + 2 = 7 。</span><br><span class="line">- 你的精力与经验都超过第 1 个对手，所以获胜。</span><br><span class="line">  精力变为：10 - 4 = 6 ，经验变为：7 + 6 = 13 。</span><br><span class="line">- 你的精力与经验都超过第 2 个对手，所以获胜。</span><br><span class="line">  精力变为：6 - 3 = 3 ，经验变为：13 + 3 = 16 。</span><br><span class="line">- 你的精力与经验都超过第 3 个对手，所以获胜。</span><br><span class="line">  精力变为：3 - 2 = 1 ，经验变为：16 + 1 = 17 。</span><br><span class="line">在比赛前进行了 8 小时训练，所以返回 8 。</span><br><span class="line">可以证明不存在更小的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]</span><br><span class="line">输出：0</span><br><span class="line">解释：你不需要额外的精力和经验就可以赢得比赛，所以返回 0 。</span><br></pre></td></tr></table></figure><p>模拟即可</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, vector&lt;<span class="type">int</span>&gt;&amp; energy, vector&lt;<span class="type">int</span>&gt;&amp; experience)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t:energy)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=initialEnergy) res+=sum-initialEnergy+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(initialExperience&lt;=experience[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">             res+=experience[<span class="number">0</span>]-initialExperience+<span class="number">1</span>;</span><br><span class="line">             initialExperience=experience[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;experience.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> te=initialExperience+experience[i];</span><br><span class="line">            <span class="keyword">if</span>(te&lt;=experience[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res+=experience[i+<span class="number">1</span>]-te+<span class="number">1</span>;</span><br><span class="line">                initialExperience=experience[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                initialExperience+=experience[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题14</title>
      <link href="/2023/03/09/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9814/"/>
      <url>/2023/03/09/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9814/</url>
      
        <content type="html"><![CDATA[<h4 id="2379-得到-K-个黑块的最少涂色次数"><a href="#2379-得到-K-个黑块的最少涂色次数" class="headerlink" title="2379. 得到 K 个黑块的最少涂色次数"></a><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">2379. 得到 K 个黑块的最少涂色次数</a></h4><p>给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的字符串 <code>blocks</code> ，<code>blocks[i]</code> 要么是 <code>&#39;W&#39;</code> 要么是 <code>&#39;B&#39;</code> ，表示第 <code>i</code> 块的颜色。字符 <code>&#39;W&#39;</code> 和 <code>&#39;B&#39;</code> 分别表示白色和黑色。</p><p>给你一个整数 <code>k</code> ，表示想要 <strong>连续</strong> 黑色块的数目。</p><p>每一次操作中，你可以选择一个白色块将它 <strong>涂成</strong> 黑色块。</p><p>请你返回至少出现 <strong>一次</strong> 连续 <code>k</code> 个黑色块的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。</span><br><span class="line">得到 blocks = &quot;BBBBBBBWBW&quot; 。</span><br><span class="line">可以证明无法用少于 3 次操作得到 7 个连续的黑块。</span><br><span class="line">所以我们返回 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：blocks = &quot;WBWBBBW&quot;, k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">不需要任何操作，因为已经有 2 个连续的黑块。</span><br><span class="line">所以我们返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == blocks.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>blocks[i]</code> 要么是 <code>&#39;W&#39;</code> ，要么是 <code>&#39;B&#39;</code> 。</li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><strong>思路</strong></p><p>1.暴力</p><p>直接用k个B和原字符串依次比较（采用01异或处理）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=blocks.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; trans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;blocks.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(blocks[i]==<span class="string">&#x27;W&#x27;</span>) trans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> trans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(k,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n-k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sub[j]^trans[j+i]==<span class="number">1</span>) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            res=<span class="built_in">min</span>(res,ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路二：</strong></p><p>最基础的滑动窗口，设定一个k长度的滑动窗口，当左边滑出的是w时，将操作次数-1，右边滑入的是w时，将操作次数+1。最初是前k个字符中w的个数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(blocks[r]==<span class="string">&#x27;W&#x27;</span>) cnt++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(r&lt;blocks.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cnt-=blocks[l]==<span class="string">&#x27;W&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            cnt+=blocks[r]==<span class="string">&#x27;W&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            res=<span class="built_in">min</span>(res,cnt);</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题13</title>
      <link href="/2023/03/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9813/"/>
      <url>/2023/03/08/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9813/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-47-礼物的最大价值"><a href="#剑指-Offer-47-礼物的最大价值" class="headerlink" title="剑指 Offer 47. 礼物的最大价值"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">剑指 Offer 47. 礼物的最大价值</a></h4><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt; grid.length &lt;= 200</code></li><li><code>0 &lt; grid[0].length &lt;= 200</code></li></ul><p><strong>思路</strong></p><p>动态规划,**dp[i][<strong>j</strong>]**就是走到（i，j）格时的最大价值。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> dp[N][N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m=grid.<span class="built_in">size</span>(),n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&lt;<span class="number">0</span>) dp[i][j]=dp[i][j<span class="number">-1</span>]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j<span class="number">-1</span>&lt;<span class="number">0</span>) dp[i][j]=dp[i<span class="number">-1</span>][j]+grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化一下，直接从1开始循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[j] = Math.<span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题12</title>
      <link href="/2023/03/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9812/"/>
      <url>/2023/03/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9812/</url>
      
        <content type="html"><![CDATA[<h4 id="1096-花括号展开-II"><a href="#1096-花括号展开-II" class="headerlink" title="1096. 花括号展开 II"></a><a href="https://leetcode.cn/problems/brace-expansion-ii/">1096. 花括号展开 II</a></h4><p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p><p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p><ul><li><p>如果只给出单一的元素 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure><p>，那么表达式表示的字符串就只有 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;x&quot;</span><br></pre></td></tr></table></figure><p>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(x) = &#123;x&#125;</span><br></pre></td></tr></table></figure><ul><li>例如，表达式 <code>&quot;a&quot;</code> 表示字符串 <code>&quot;a&quot;</code>。</li><li>而表达式 <code>&quot;w&quot;</code> 就表示字符串 <code>&quot;w&quot;</code>。</li></ul></li><li><p>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(&#123;e_1,e_2,...&#125;) = R(e_1) ∪ R(e_2) ∪ ...</span><br></pre></td></tr></table></figure><ul><li>例如，表达式 <code>&quot;&#123;a,b,c&#125;&quot;</code> 表示字符串 <code>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</code>。</li><li>而表达式 <code>&quot;&#123;&#123;a,b&#125;,&#123;b,c&#125;&#125;&quot;</code> 也可以表示字符串 <code>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</code>。</li></ul></li><li><p>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(e_1 + e_2) = &#123;a + b for (a, b) in R(e_1) × R(e_2)&#125;</span><br></pre></td></tr></table></figure><ul><li>例如，表达式 <code>&quot;&#123;a,b&#125;&#123;c,d&#125;&quot;</code> 表示字符串 <code>&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;</code>。</li></ul></li><li><p>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。</p><ul><li>例如，表达式 <code>&quot;a&#123;b,c,d&#125;&quot;</code> 表示字符串 <code>&quot;ab&quot;,&quot;ac&quot;,&quot;ad&quot;</code>。</li><li>例如，表达式 <code>&quot;a&#123;b,c&#125;&#123;d,e&#125;f&#123;g,h&#125;&quot;</code> 可以表示字符串 <code>&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;</code>。</li></ul></li></ul><p>给出表示基于给定语法规则的表达式 <code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p><p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = &quot;&#123;a,b&#125;&#123;c,&#123;d,e&#125;&#125;&quot;</span><br><span class="line">输出：[&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = &quot;&#123;&#123;a,z&#125;,a&#123;b,c&#125;,&#123;ab,z&#125;&#125;&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;]</span><br><span class="line">解释：输出中 不应 出现重复的组合结果。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>先找第一个右花括号，如果没有那就直接在set中插入全部expression</p><p>否则，找该右花括号左边的第一个左花括号，然后把字符串分为三部分：a（分割字符串的前缀），b（分割字符串），c（分割字符串的后缀），那么新生成的表达式就是a+b+c，于是继续dfs直到没有右花括号为止。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string expression)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j=expression.<span class="built_in">find_first_of</span>(<span class="string">&quot;&#125;&quot;</span>);  <span class="comment">//找到第一个右花括号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(expression);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=expression.<span class="built_in">rfind</span>(<span class="string">&#x27;&#123;&#x27;</span>,j);  <span class="comment">//找该右花括号的第一个左花括号</span></span><br><span class="line">        string a=expression.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">        string c=expression.<span class="built_in">substr</span>(j+<span class="number">1</span>);</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(expression.substr(i + <span class="number">1</span>, j - i - <span class="number">1</span>))</span></span>;</span><br><span class="line">        string b;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,b,<span class="string">&#x27;,&#x27;</span>)) <span class="comment">//对每个bi都进行a+b+c的dfs</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(a+b+c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">braceExpansionII</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(expression);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题11</title>
      <link href="/2023/03/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9811/"/>
      <url>/2023/03/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9811/</url>
      
        <content type="html"><![CDATA[<h4 id="1653-使字符串平衡的最少删除次数"><a href="#1653-使字符串平衡的最少删除次数" class="headerlink" title="1653. 使字符串平衡的最少删除次数"></a><a href="https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/">1653. 使字符串平衡的最少删除次数</a></h4><p>给你一个字符串 <code>s</code> ，它仅包含字符 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 。</p><p>你可以删除 <code>s</code> 中任意数目的字符，使得 <code>s</code> <strong>平衡</strong> 。当不存在下标对 <code>(i,j)</code> 满足 <code>i &lt; j</code> ，且 <code>s[i] = &#39;b&#39;</code> 的同时 <code>s[j]= &#39;a&#39;</code> ，此时认为 <code>s</code> 是 <strong>平衡</strong> 的。</p><p>请你返回使 <code>s</code> <strong>平衡</strong> 的 <strong>最少</strong> 删除次数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aababbab&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：你可以选择以下任意一种方案：</span><br><span class="line">下标从 0 开始，删除第 2 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aaabbb&quot;），</span><br><span class="line">下标从 0 开始，删除第 3 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aabbbb&quot;）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbaaaaabb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：唯一的最优解是删除最前面两个字符。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>动态规划：用dp作为删除次数，判断末尾是a和末尾是b两种情况</p><p>当末尾是a时，分为两种：①删除这个a，dp次数+1；②删除这个a前面所有的b，dp次数+前面b的数量。取二者最小</p><p>当末尾是b时，我们直接加到b的个数里</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDeletions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="type">int</span> dp=<span class="number">0</span>,countb=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当末尾是a的时候，删除这个a或者保留这个a，删除前面所有的b（b有countb来计数）</span></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;a&#x27;</span>) dp=<span class="built_in">min</span>(dp+<span class="number">1</span>,countb);</span><br><span class="line">            <span class="keyword">else</span> countb++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala基础</title>
      <link href="/2023/03/05/Scala%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/05/Scala%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一个最初的Hello-world程序"><a href="#1-一个最初的Hello-world程序" class="headerlink" title="1.一个最初的Hello world程序"></a><strong>1.一个最初的Hello world程序</strong></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个 Scala 程序</span></span><br><span class="line"><span class="comment">    * 以下程序将输出&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">      println(<span class="string">&quot;Hello, world!&quot;</span>) <span class="comment">// 输出 Hello World</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-scala中，每行只有一句时可以不写分号，一行多句要写"><a href="#2-scala中，每行只有一句时可以不写分号，一行多句要写" class="headerlink" title="2.scala中，每行只有一句时可以不写分号，一行多句要写"></a><strong>2.scala中，每行只有一句时可以不写分号，一行多句要写</strong></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;菜鸟教程&quot;</span>; println(s)</span><br></pre></td></tr></table></figure><h2 id="3-scala包"><a href="#3-scala包" class="headerlink" title="3.scala包"></a><strong>3.scala包</strong></h2><p>和java一样</p><h2 id="4-字符字面量"><a href="#4-字符字面量" class="headerlink" title="4.字符字面量"></a>4.字符字面量</h2><p>在 Scala 字符变量使用单引号 <strong>‘</strong> 来定义，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;a&#x27; </span><br><span class="line">&#x27;\u0041&#x27;</span><br><span class="line">&#x27;\n&#x27;</span><br><span class="line">&#x27;\t&#x27;</span><br></pre></td></tr></table></figure><p>其中 *<em>*</em> 表示转义字符，其后可以跟 <strong>u0041</strong> 数字或者 <strong>\r\n</strong> 等固定的转义字符。</p><h2 id="5-字符串字面量"><a href="#5-字符串字面量" class="headerlink" title="5.字符串字面量"></a>5.字符串字面量</h2><p>在 Scala 字符串字面量使用双引号 <strong>“</strong> 来定义，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello,\nWorld!&quot;</span></span><br><span class="line"><span class="string">&quot;菜鸟教程官网：www.runoob.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-多行字符串的表示方法"><a href="#6-多行字符串的表示方法" class="headerlink" title="6.多行字符串的表示方法"></a>6.多行字符串的表示方法</h2><p>多行字符串用三个双引号来表示分隔符，格式为：**””” … “””**。</p><p>实例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> foo = <span class="string">&quot;&quot;&quot;菜鸟教程</span></span><br><span class="line"><span class="string">www.runoob.com</span></span><br><span class="line"><span class="string">www.w3cschool.cc</span></span><br><span class="line"><span class="string">www.runnoob.com</span></span><br><span class="line"><span class="string">以上三个地址都能访问&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="7-变量声明"><a href="#7-变量声明" class="headerlink" title="7.变量声明"></a>7.变量声明</h2><p>在学习如何声明变量与常量之前，我们先来了解一些变量与常量。</p><ul><li>一、变量： 在程序运行过程中其值可能发生改变的量叫做变量。如：时间，年龄。</li><li>二、常量 在程序运行过程中其值不会发生变化的量叫做常量。如：数值 3，字符’A’。</li></ul><p>在 Scala 中，使用关键词 <strong>“var”</strong> 声明变量，使用关键词 <strong>“val”</strong> 声明常量。</p><p>声明变量实例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">&quot;Foo&quot;</span></span><br><span class="line"><span class="keyword">var</span> myVar : <span class="type">String</span> = <span class="string">&quot;Too&quot;</span></span><br></pre></td></tr></table></figure><p>以上定义了变量 myVar，我们可以修改它。</p><p>声明常量实例如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myVal : <span class="type">String</span> = <span class="string">&quot;Foo&quot;</span></span><br></pre></td></tr></table></figure><p>以上定义了常量 myVal，它是不能修改的。如果程序尝试修改常量 myVal 的值，程序将会在编译时报错。</p><h2 id="变量类型引用"><a href="#变量类型引用" class="headerlink" title="变量类型引用"></a>变量类型引用</h2><p>在 Scala 中声明变量和常量不一定要指明数据类型，在没有指明数据类型的情况下，其数据类型是通过变量或常量的初始值推断出来的。</p><p>所以，如果在没有指明数据类型的情况下声明变量或常量必须要给出其初始值，否则将会报错。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">val</span> myVal = <span class="string">&quot;Hello, Scala!&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上实例中，myVar 会被推断为 Int 类型，myVal 会被推断为 String 类型。</p><hr><h2 id="Scala-多个变量声明"><a href="#Scala-多个变量声明" class="headerlink" title="Scala 多个变量声明"></a>Scala 多个变量声明</h2><p>Scala 支持多个变量的声明：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> xmax, ymax = <span class="number">100</span>  <span class="comment">// xmax, ymax都声明为100</span></span><br></pre></td></tr></table></figure><p>如果方法返回值是元组，我们可以使用 val 来声明一个元组：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> pa = (<span class="number">40</span>,<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">pa: (<span class="type">Int</span>, <span class="type">String</span>) = (<span class="number">40</span>,<span class="type">Foo</span>)</span><br></pre></td></tr></table></figure><h2 id="8-Scala-访问修饰符"><a href="#8-Scala-访问修饰符" class="headerlink" title="8.Scala 访问修饰符"></a>8.Scala 访问修饰符</h2><p>Scala 访问修饰符基本和Java的一样，分别有：private，protected，public。</p><p>如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public。</p><p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p><h2 id="私有-Private-成员"><a href="#私有-Private-成员" class="headerlink" title="私有(Private)成员"></a>私有(Private)成员</h2><p>用 private 关键字修饰，带有此标记的成员仅在包含了成员定义的类或对象内部可见，同样的规则还适用内部类。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>()&#123;</span><br><span class="line">      println(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span></span>&#123;</span><br><span class="line">      f() <span class="comment">// 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(new Inner).f( )</strong> 访问不合法是因为 <strong>f</strong> 在 Inner 中被声明为 private，而访问不在类 Inner 之内。</p><p>但在 InnerMost 里访问 <strong>f</strong> 就没有问题的，因为这个访问包含在 Inner 类之内。</p><p>Java 中允许这两种访问，因为它允许外部类访问内部类的私有成员。</p><h2 id="保护-Protected-成员"><a href="#保护-Protected-成员" class="headerlink" title="保护(Protected)成员"></a>保护(Protected)成员</h2><p>在 scala 中，对保护（Protected）成员的访问比 java 更严格一些。因为它只允许保护成员在定义了该成员的的类的子类中被访问。而在java中，用 protected关键字修饰的成员，除了定义了该成员的类的子类可以访问，同一个包里的其他类也可以进行访问。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> p &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123;println(<span class="string">&quot;f&quot;</span>)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    f()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Other</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> <span class="type">Super</span>).f() <span class="comment">//错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，Sub 类对 f 的访问没有问题，因为 f 在 Super 中被声明为 protected，而 Sub 是 Super 的子类。相反，Other 对 f 的访问不被允许，因为 other 没有继承自 Super。而后者在 java 里同样被认可，因为 Other 与 Sub 在同一包里。</p><h2 id="公共-Public-成员"><a href="#公共-Public-成员" class="headerlink" title="公共(Public)成员"></a>公共(Public)成员</h2><p>Scala 中，如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问。</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f</span></span>() &#123; println(<span class="string">&quot;f&quot;</span>) &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">InnerMost</span> </span>&#123;</span><br><span class="line">     f() <span class="comment">// 正确</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  (<span class="keyword">new</span> <span class="type">Inner</span>).f() <span class="comment">// 正确因为 f() 是 public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spark+Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题10</title>
      <link href="/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9810/"/>
      <url>/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9810/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><a href="http://118.190.20.162/view.page?gpid=T159">问题描述</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>本题就是关键路径的计算</p><p>70分：只计算最早开始时间</p><p><strong>{</strong></p><p>​如果依赖为0，那么直接置<strong>first[i]&#x3D;1</strong>，然后计算该项目的最早结束时间<strong>need[i]</strong></p><p>​依赖不为0时，找到依赖的项目**yilai[i]<strong>，依赖项目最早结束时间</strong>need[yilai[i]]**就是该项目最早开始时间，然后再计算该项目最早结束时间</p><p><strong>}</strong></p><p>100分：计算最晚开始时间</p><p><strong>{</strong></p><p>​因为题目说，依赖的项目编号一定小于自身，所以我们<strong>倒着遍历</strong></p><p>​如果依赖不为0，那么<strong>last[i]<strong>有两种情况，如果这个</strong>last[i]<strong>已经存在值，说明该项目被别的项目依赖过，那么取</strong>记录值</strong>和<strong>n-needday[i]+1</strong>的最小值，否则<strong>last[i]&#x3D;n-needday[i]+1</strong></p><p>​然后我们计算该项目依赖项目的最晚开始时间，是<strong>本项目的最晚开始时间-依赖项目的耗时</strong>，也就是<strong>last[yilai[i]]&#x3D;last[i]-needday[yilai[i]]</strong>,同样我们需要判断一下**last[yilai[i]]**是否存在，来应对多个项目依赖同一个项目的情况。</p><p>​如果这个<strong>last[yilai[i]]<strong>已经存在值，说明该项目也被别的项目依赖过，那么取</strong>记录值</strong>和<strong>last[i]-needday[yilai[i]]<strong>的最小值，否则</strong>last[yilai[i]]&#x3D;last[i]-needday[yilai[i]]</strong></p><p>​然后再遍历一遍，把与依赖无关的所有其他项目赋上最晚开始时间<strong>last[i]&#x3D;n-needday[i]+1</strong></p><p><strong>}</strong></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">370</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> yilai[N],needday[N];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; first;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; need,needlast;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;yilai[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;needday[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(yilai[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            first[i]=<span class="number">1</span>;</span><br><span class="line">            need[i]=<span class="number">1</span>+needday[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first[i]=need[yilai[i]];</span><br><span class="line">            need[i]=first[i]+needday[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(need[i]<span class="number">-1</span>&gt;n) flag=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=first.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;it!=first.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//70分就不用写下面这个if  100分要算最晚完成时间</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(yilai[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(last[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    last[i]=<span class="built_in">min</span>(last[i],n-needday[i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    last[i]=n-needday[i]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(last[yilai[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    last[yilai[i]]=<span class="built_in">min</span>(last[yilai[i]],last[i]-needday[yilai[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    last[yilai[i]]=last[i]-needday[yilai[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last[i]==<span class="number">0</span>) last[i]=n-needday[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it1=last.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(;it1!=last.<span class="built_in">end</span>();it1++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;it1-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CCFCSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题8</title>
      <link href="/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%988/"/>
      <url>/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%988/</url>
      
        <content type="html"><![CDATA[<h4 id="1599-经营摩天轮的最大利润"><a href="#1599-经营摩天轮的最大利润" class="headerlink" title="1599. 经营摩天轮的最大利润"></a><a href="https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/">1599. 经营摩天轮的最大利润</a></h4><p>你正在经营一座摩天轮，该摩天轮共有 <strong>4 个座舱</strong> ，每个座舱 <strong>最多可以容纳 4 位游客</strong> 。你可以 <strong>逆时针</strong> 轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 1 &#x2F; 4 周。</p><p>给你一个长度为 <code>n</code> 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 <code>i</code> 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 <strong>在服务所有游客之前</strong> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，<strong>将免费进行****所有后续轮转</strong> 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <strong>下一次轮转</strong> 。</p><p>返回最大化利润所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/wheeldiagram12.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [8,3], boardingCost = 5, runningCost = 6</span><br><span class="line">输出：3</span><br><span class="line">解释：座舱上标注的数字是该座舱的当前游客数。</span><br><span class="line">1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。</span><br><span class="line">2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。</span><br><span class="line">3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。</span><br><span class="line">轮转 3 次得到最大利润，最大利润为 $37 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [10,9,6], boardingCost = 6, runningCost = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。</span><br><span class="line">2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。</span><br><span class="line">3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。</span><br><span class="line">4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。</span><br><span class="line">5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。</span><br><span class="line">6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。</span><br><span class="line">7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。</span><br><span class="line">轮转 7 次得到最大利润，最大利润为$122 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。</span><br><span class="line">2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。</span><br><span class="line">3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。</span><br><span class="line">4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。</span><br><span class="line">5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。</span><br><span class="line">利润永不为正，所以返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>直接模拟即可，只能说这题有各种限制条件恶心你</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123;</span><br><span class="line">        int money=0;</span><br><span class="line">        int people=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        int maxmoney=0;</span><br><span class="line">        for(auto c:customers)</span><br><span class="line">        &#123;</span><br><span class="line">            people+=c;</span><br><span class="line">            if(people&gt;=4)</span><br><span class="line">            &#123;</span><br><span class="line">                money+=4*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;maxmoney)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people-=4;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(people&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                money+=people*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;=maxmoney)  //最后加了个等号才过的最后一个案例，利润在中间可能存在相等的情况</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else  //这里  如果people降到0了也要转一次</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(people!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(people&gt;=4)</span><br><span class="line">            &#123;</span><br><span class="line">                money+=4*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;maxmoney)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people-=4;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                money+=people*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;maxmoney)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(maxmoney==0) return -1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题9</title>
      <link href="/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%989/"/>
      <url>/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%989/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><a href="http://118.190.20.162/view.page?gpid=T160">问题描述</a></h2><p><strong>思路</strong></p><p>模拟即可，注意是输入n+1行数据</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">double</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> i;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> money=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n+<span class="number">1</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;w[k]);</span><br><span class="line">        <span class="keyword">if</span>(w[k]&gt;<span class="number">0</span>) money+=w[k]*<span class="built_in">pow</span>((<span class="number">1</span>+i),-k);</span><br><span class="line">        <span class="keyword">else</span> money+=w[k]*<span class="built_in">pow</span>((<span class="number">1</span>+i),-k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,money);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CCFCSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题6</title>
      <link href="/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%986/"/>
      <url>/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<h4 id="982-按位与为零的三元组"><a href="#982-按位与为零的三元组" class="headerlink" title="982. 按位与为零的三元组"></a><a href="https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/">982. 按位与为零的三元组</a></h4><p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p><p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p><ul><li><code>0 &lt;= i &lt; nums.length</code></li><li><code>0 &lt;= j &lt; nums.length</code></li><li><code>0 &lt;= k &lt; nums.length</code></li><li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1,3]</span><br><span class="line">输出：12</span><br><span class="line">解释：可以选出如下 i, j, k 三元组：</span><br><span class="line">(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1</span><br><span class="line">(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2</span><br><span class="line">(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1</span><br><span class="line">(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3</span><br><span class="line">(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1</span><br><span class="line">(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2</span><br><span class="line">(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1</span><br><span class="line">(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3</span><br><span class="line">(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2</span><br><span class="line">(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2</span><br><span class="line">(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1</span><br><span class="line">(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：27</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先任选两个数进行位与运算，然后用哈希表储存，再和第三个数位与。</p><p>将结果为0的，直接加上哈希表后面的统计个数，这样可以减少时间复杂度</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; judge;</span><br><span class="line"><span class="comment">//将前两个任选数位与结果存进哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; j:nums)</span><br><span class="line">            &#123;</span><br><span class="line">                judge[i&amp;j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//与第三个数进行位与运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [k,v]:judge)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((k&amp;x)==<span class="number">0</span>) res+=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题7</title>
      <link href="/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%987/"/>
      <url>/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%987/</url>
      
        <content type="html"><![CDATA[<h2 id="何以包邮？"><a href="#何以包邮？" class="headerlink" title="何以包邮？"></a>何以包邮？</h2><p>新学期伊始，适逢顿顿书城有购书满 x元包邮的活动，小 P 同学欣然前往准备买些参考书。</p><p>一番浏览后，小 P 初步筛选出 n本书加入购物车中，其中第 i 本（1≤i≤n）的价格为 ai 元。</p><p>考虑到预算有限，在最终付款前小 P 决定再从购物车中删去几本书（也可以不删），使得剩余图书的价格总和 m 在满足包邮条件（m≥x）的前提下最小。</p><p>试帮助小 P 计算，最终选购哪些书可以在凑够 x 元包邮的前提下花费最小？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含空格分隔的两个正整数 n 和 x，分别表示购物车中图书数量和包邮条件。</p><p>接下来输入 n 行，其中第 i 行（1≤i≤n1）仅包含一个正整数 ai，表示购物车中第 i 本书的价格。</p><p>输入数据保证 n 本书的价格总和不小于 x。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>仅输出一个正整数，表示在满足包邮条件下的最小花费。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>70%70% 的测试数据满足：n≤15；<br>全部的测试数据满足：n≤30，每本书的价格 ai≤10^4 且 x≤a1+a2+⋯+an。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 100</span><br><span class="line">20</span><br><span class="line">90</span><br><span class="line">60</span><br><span class="line">60</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110</span><br></pre></td></tr></table></figure><h4 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h4><p>购买前两本书 (20+90) 即可包邮且花费最小。</p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 30</span><br><span class="line">15</span><br><span class="line">40</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="样例2解释"><a href="#样例2解释" class="headerlink" title="样例2解释"></a>样例2解释</h4><p>仅购买第三本书恰好可以满足包邮条件。</p><h4 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 90</span><br><span class="line">50</span><br><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="样例3解释"><a href="#样例3解释" class="headerlink" title="样例3解释"></a>样例3解释</h4><p>必须全部购买才能包邮。</p><h3 id="解法一：暴力解法（70分）"><a href="#解法一：暴力解法（70分）" class="headerlink" title="解法一：暴力解法（70分）"></a>解法一：暴力解法（70分）</h3><p>用n位二进制数，1代表选了对应位置的书，0代表没选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span>  w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">1e8</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)  <span class="comment">//枚举从0到2^n-1的所有的数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) sum+=w[j];  <span class="comment">//在二进制表示当中i的第j位是1 表示选了第j本书</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=m) res=<span class="built_in">min</span>(res,sum); <span class="comment">//如果大于包邮邮费，就更新最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>暴力dfs：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span>  w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=m) res=<span class="built_in">min</span>(sum,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(u+<span class="number">1</span>,sum); <span class="comment">//不选这本书</span></span><br><span class="line">        <span class="built_in">dfs</span>(u+<span class="number">1</span>,sum+w[u]); <span class="comment">//选这本书</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二：转换为01背包问题（100分）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题转化为  选择若干本书，使得总和不超过sum-x的前提下，总和越大越好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成背包问题：背包容量：sum-x  每个物品的体积 w[i]  每个物品的价值 w[i]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//背包问题两重循环： 先枚举每个物品，再倒序枚举每个体积</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>,M=<span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">//动态规划的数据 长度是最大数量*最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        sum+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m=sum-x;  <span class="comment">//背包容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始背包问题循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;sum-f[m]&lt;&lt;endl;  <span class="comment">//f[m]就是最大的结果，再用sum减去</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CCFCSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题5</title>
      <link href="/2023/03/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%985/"/>
      <url>/2023/03/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h4 id="1487-保证文件名唯一"><a href="#1487-保证文件名唯一" class="headerlink" title="1487. 保证文件名唯一"></a><a href="https://leetcode.cn/problems/making-file-names-unique/">1487. 保证文件名唯一</a></h4><p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p><p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p><p>返回长度为 <em><code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">输出：[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line">&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;</span><br><span class="line">&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;</span><br><span class="line">&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;</span><br><span class="line">&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]</span><br><span class="line">输出：[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line">&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;</span><br><span class="line">&quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot;</span><br><span class="line">&quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。</span><br><span class="line">&quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]</span><br><span class="line">输出：[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]</span><br><span class="line">解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]</span><br><span class="line">输出：[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]</span><br><span class="line">解释：每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]</span><br><span class="line">输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]</span><br><span class="line">解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用哈希表存储已经创建过的文件名，用k记录后缀次数</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getFolderNames</span><span class="params">(vector&lt;string&gt;&amp; names)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; order;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:names)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(order[t]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t);</span><br><span class="line">                <span class="comment">//记录第一次被创建的文件名</span></span><br><span class="line">                order[t]=<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k=order[t];</span><br><span class="line">                <span class="keyword">while</span>(order[t+<span class="string">&#x27;(&#x27;</span>+<span class="built_in">to_string</span>(k)+<span class="string">&#x27;)&#x27;</span>]!=<span class="number">0</span>) k++;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t+<span class="string">&#x27;(&#x27;</span>+<span class="built_in">to_string</span>(k)+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                <span class="comment">//优化查询速度，降低时间复杂度  文件t已被记录k次，而带k后缀的文件第一次被记录</span></span><br><span class="line">                order[t]=k+<span class="number">1</span>;</span><br><span class="line">                order[t+<span class="string">&#x27;(&#x27;</span>+<span class="built_in">to_string</span>(k)+<span class="string">&#x27;)&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题4</title>
      <link href="/2023/03/02/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%984/"/>
      <url>/2023/03/02/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h4 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a href="https://leetcode.cn/problems/bianry-number-to-string-lcci/">面试题 05.02. 二进制数转字符串</a></h4><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：0.625</span><br><span class="line">输出：&quot;0.101&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：0.1</span><br><span class="line">输出：&quot;ERROR&quot;</span><br><span class="line">提示：0.1无法被二进制准确表示</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>32位包括输出中的 <code>&quot;0.&quot;</code> 这两位。</li><li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li></ul><p><strong>思路：</strong></p><p>用一个judge存储计算结果，实时比较对应置0和置1，如果在30(32-2)位内还没有得出结果，就返回ERROR。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">printBin</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        string res=<span class="string">&quot;0.&quot;</span>;</span><br><span class="line">        <span class="type">double</span> judge=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(judge+(<span class="number">1</span>/<span class="built_in">pow</span>(<span class="number">2</span>,i))&gt;num) res+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res+=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">                judge+=<span class="number">1</span>/<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge==num) <span class="keyword">return</span> res;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题3</title>
      <link href="/2023/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%983/"/>
      <url>/2023/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h4 id="2373-矩阵中的局部最大值"><a href="#2373-矩阵中的局部最大值" class="headerlink" title="2373. 矩阵中的局部最大值"></a><a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/">2373. 矩阵中的局部最大值</a></h4><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p><p>生成一个大小为 <code>(n - 2) x (n - 2)</code> 的整数矩阵 <code>maxLocal</code> ，并满足：</p><ul><li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li></ul><p>换句话说，我们希望找出 <code>grid</code> 中每个 <code>3 x 3</code> 矩阵中的最大值。</p><p>返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/06/21/ex1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]</span><br><span class="line">输出：[[9,9],[8,6]]</span><br><span class="line">解释：原矩阵和生成的矩阵如上图所示。</span><br><span class="line">注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]</span><br><span class="line">输出：[[2,2,2],[2,2,2],[2,2,2]]</span><br><span class="line">解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。</span><br></pre></td></tr></table></figure><p>直接模拟即可</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">largestLocal</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n<span class="number">-2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">-2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">                <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=i+<span class="number">2</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> z=j;z&lt;=j+<span class="number">2</span>;z++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=<span class="built_in">max</span>(grid[k][z],temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i][j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：二维vector数组的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; 名字(size1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size2, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵计算 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题2</title>
      <link href="/2023/02/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%982/"/>
      <url>/2023/02/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h2><h4 id="2363-合并相似的物品"><a href="#2363-合并相似的物品" class="headerlink" title="2363. 合并相似的物品"></a><a href="https://leetcode.cn/problems/merge-similar-items/">2363. 合并相似的物品</a></h4><p>给你两个二维整数数组 <code>items1</code> 和 <code>items2</code> ，表示两个物品集合。每个数组 <code>items</code> 有以下特质：</p><ul><li><code>items[i] = [valuei, weighti]</code> 其中 <code>valuei</code> 表示第 <code>i</code> 件物品的 <strong>价值</strong> ，<code>weighti</code> 表示第 <code>i</code> 件物品的 <strong>重量</strong> 。</li><li><code>items</code> 中每件物品的价值都是 <strong>唯一的</strong> 。</li></ul><p>请你返回一个二维数组 <code>ret</code>，其中 <code>ret[i] = [valuei, weighti]</code>， <code>weighti</code> 是所有价值为 <code>valuei</code> 物品的 <strong>重量之和</strong> 。</p><p><strong>注意：</strong><code>ret</code> 应该按价值 <strong>升序</strong> 排序后返回。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]</span><br><span class="line">输出：[[1,6],[3,9],[4,5]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。</span><br><span class="line">value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。</span><br><span class="line">value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。</span><br><span class="line">所以，我们返回 [[1,6],[3,9],[4,5]] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]</span><br><span class="line">输出：[[1,4],[2,4],[3,4]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。</span><br><span class="line">value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">所以，我们返回 [[1,4],[2,4],[3,4]] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]</span><br><span class="line">输出：[[1,7],[2,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。</span><br><span class="line">所以，我们返回 [[1,7],[2,4],[7,1]] 。</span><br></pre></td></tr></table></figure><p>思路：使用哈希表将相同价值的重量加在一起，最后再排序即可</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items2) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; judge;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:items1)</span><br><span class="line">        &#123;</span><br><span class="line">            judge[t[<span class="number">0</span>]]+=t[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:items2)</span><br><span class="line">        &#123;</span><br><span class="line">            judge[t[<span class="number">0</span>]]+=t[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=judge.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(;it!=judge.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;it-&gt;first,it-&gt;second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题1</title>
      <link href="/2023/02/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%981/"/>
      <url>/2023/02/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="1144-递减元素使数组呈锯齿状"><a href="#1144-递减元素使数组呈锯齿状" class="headerlink" title="1144. 递减元素使数组呈锯齿状"></a>1144. 递减元素使数组呈锯齿状</h2><p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p><p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p><ul><li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li><li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li></ul><p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以把 2 递减到 0，或把 3 递减到 1。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：nums = [9,6,1,6,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="思路：枚举-贪心"><a href="#思路：枚举-贪心" class="headerlink" title="思路：枚举+贪心"></a>思路：枚举+贪心</h2><p>​分别算出偶数索引大和奇数索引大的两种情况需要操作的最小次数，比较求之即可。</p><h2 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums1=nums; <span class="comment">//防止第一次计算时数组变化，备份一份</span></span><br><span class="line">        <span class="type">int</span> res1=<span class="number">0</span>,res2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//奇数索引最大时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res1+=nums[i]-nums[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums[i]=nums[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res1+=nums[i]-nums[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums[i]=nums[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//偶数索引最大时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums1[i]&gt;=nums1[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res2+=nums1[i]-nums1[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums1[i]=nums1[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums1[i]&gt;=nums1[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res2+=nums1[i]-nums1[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums1[i]=nums1[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路考试范围</title>
      <link href="/2023/01/06/%E7%94%B5%E8%B7%AF%E8%80%83%E8%AF%95/"/>
      <url>/2023/01/06/%E7%94%B5%E8%B7%AF%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>交作业时间 雨课堂  还有感想意见也要写<br>电路考试题型<br>8个小主观题  6*8&#x3D;48<br>必考内容<br>直流<br>第一章 简单直流电路的分析 KCL KVL 功率<br>第二章 对象化简 二端口网络<br>第四章 叠加定理<br>交流<br>相量法简单计算 简单交流电路<br>谐振（去耦 理想变压器等）<br>非正弦交流 公式<br>三相电路中间的量表法</p><p>五个大题<br>必考<br>1.节点法和回路法（2选1）<br>2.交流电路分析（相量图）<br>3.三相电路分析（对称或简单不对称）计算器<br>4.一阶电路分析<br>5.二端口网络&#x2F;定理综合应用 等 待定</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建历程</title>
      <link href="/2022/12/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"/>
      <url>/2022/12/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-12-28"><a href="#2022-12-28" class="headerlink" title="2022.12.28"></a>2022.12.28</h1><p>正式建立博客并设置了背景，添加搜索功能，为顶部底部添加透明css文件等一系列美化措施。</p><h1 id="2023-2-18-2023-2-28"><a href="#2023-2-18-2023-2-28" class="headerlink" title="2023.2.18-2023.2.28"></a>2023.2.18-2023.2.28</h1><ul><li>1.加入了Aplayer播放器</li><li>2.个人卡渐变</li><li>3.首页文章分栏显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/12/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>##第一篇文章</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
