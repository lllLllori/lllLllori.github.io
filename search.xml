<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法刷题12</title>
      <link href="/2023/03/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9812/"/>
      <url>/2023/03/07/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9812/</url>
      
        <content type="html"><![CDATA[<h4 id="1096-花括号展开-II"><a href="#1096-花括号展开-II" class="headerlink" title="1096. 花括号展开 II"></a><a href="https://leetcode.cn/problems/brace-expansion-ii/">1096. 花括号展开 II</a></h4><p>如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。</p><p>花括号展开的表达式可以看作一个由 <strong>花括号</strong>、<strong>逗号</strong> 和 <strong>小写英文字母</strong> 组成的字符串，定义下面几条语法规则：</p><ul><li><p>如果只给出单一的元素 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x</span><br></pre></td></tr></table></figure><p>，那么表达式表示的字符串就只有 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;x&quot;</span><br></pre></td></tr></table></figure><p>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(x) = &#123;x&#125;</span><br></pre></td></tr></table></figure><ul><li>例如，表达式 <code>&quot;a&quot;</code> 表示字符串 <code>&quot;a&quot;</code>。</li><li>而表达式 <code>&quot;w&quot;</code> 就表示字符串 <code>&quot;w&quot;</code>。</li></ul></li><li><p>当两个或多个表达式并列，以逗号分隔，我们取这些表达式中元素的并集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(&#123;e_1,e_2,...&#125;) = R(e_1) ∪ R(e_2) ∪ ...</span><br></pre></td></tr></table></figure><ul><li>例如，表达式 <code>&quot;&#123;a,b,c&#125;&quot;</code> 表示字符串 <code>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</code>。</li><li>而表达式 <code>&quot;&#123;&#123;a,b&#125;,&#123;b,c&#125;&#125;&quot;</code> 也可以表示字符串 <code>&quot;a&quot;,&quot;b&quot;,&quot;c&quot;</code>。</li></ul></li><li><p>要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R(e_1 + e_2) = &#123;a + b for (a, b) in R(e_1) × R(e_2)&#125;</span><br></pre></td></tr></table></figure><ul><li>例如，表达式 <code>&quot;&#123;a,b&#125;&#123;c,d&#125;&quot;</code> 表示字符串 <code>&quot;ac&quot;,&quot;ad&quot;,&quot;bc&quot;,&quot;bd&quot;</code>。</li></ul></li><li><p>表达式之间允许嵌套，单一元素与表达式的连接也是允许的。</p><ul><li>例如，表达式 <code>&quot;a&#123;b,c,d&#125;&quot;</code> 表示字符串 <code>&quot;ab&quot;,&quot;ac&quot;,&quot;ad&quot;</code>。</li><li>例如，表达式 <code>&quot;a&#123;b,c&#125;&#123;d,e&#125;f&#123;g,h&#125;&quot;</code> 可以表示字符串 <code>&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;</code>。</li></ul></li></ul><p>给出表示基于给定语法规则的表达式 <code>expression</code>，返回它所表示的所有字符串组成的有序列表。</p><p>假如你希望以「集合」的概念了解此题，也可以通过点击 “<strong>显示英文描述</strong>” 获取详情。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = &quot;&#123;a,b&#125;&#123;c,&#123;d,e&#125;&#125;&quot;</span><br><span class="line">输出：[&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：expression = &quot;&#123;&#123;a,z&#125;,a&#123;b,c&#125;,&#123;ab,z&#125;&#125;&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;]</span><br><span class="line">解释：输出中 不应 出现重复的组合结果。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>先找第一个右花括号，如果没有那就直接在set中插入全部expression</p><p>否则，找该右花括号左边的第一个左花括号，然后把字符串分为三部分：a（分割字符串的前缀），b（分割字符串），c（分割字符串的后缀），那么新生成的表达式就是a+b+c，于是继续dfs直到没有右花括号为止。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string expression)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j=expression.<span class="built_in">find_first_of</span>(<span class="string">&quot;&#125;&quot;</span>);  <span class="comment">//找到第一个右花括号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==string::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(expression);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=expression.<span class="built_in">rfind</span>(<span class="string">&#x27;&#123;&#x27;</span>,j);  <span class="comment">//找该右花括号的第一个左花括号</span></span><br><span class="line">        string a=expression.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">        string c=expression.<span class="built_in">substr</span>(j+<span class="number">1</span>);</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(expression.substr(i + <span class="number">1</span>, j - i - <span class="number">1</span>))</span></span>;</span><br><span class="line">        string b;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,b,<span class="string">&#x27;,&#x27;</span>)) <span class="comment">//对每个bi都进行a+b+c的dfs</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(a+b+c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">braceExpansionII</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(expression);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题11</title>
      <link href="/2023/03/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9811/"/>
      <url>/2023/03/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9811/</url>
      
        <content type="html"><![CDATA[<h4 id="1653-使字符串平衡的最少删除次数"><a href="#1653-使字符串平衡的最少删除次数" class="headerlink" title="1653. 使字符串平衡的最少删除次数"></a><a href="https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/">1653. 使字符串平衡的最少删除次数</a></h4><p>给你一个字符串 <code>s</code> ，它仅包含字符 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 。</p><p>你可以删除 <code>s</code> 中任意数目的字符，使得 <code>s</code> <strong>平衡</strong> 。当不存在下标对 <code>(i,j)</code> 满足 <code>i &lt; j</code> ，且 <code>s[i] = &#39;b&#39;</code> 的同时 <code>s[j]= &#39;a&#39;</code> ，此时认为 <code>s</code> 是 <strong>平衡</strong> 的。</p><p>请你返回使 <code>s</code> <strong>平衡</strong> 的 <strong>最少</strong> 删除次数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aababbab&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：你可以选择以下任意一种方案：</span><br><span class="line">下标从 0 开始，删除第 2 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aaabbb&quot;），</span><br><span class="line">下标从 0 开始，删除第 3 和第 6 个字符（&quot;aababbab&quot; -&gt; &quot;aabbbb&quot;）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bbaaaaabb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：唯一的最优解是删除最前面两个字符。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>动态规划：用dp作为删除次数，判断末尾是a和末尾是b两种情况</p><p>当末尾是a时，分为两种：①删除这个a，dp次数+1；②删除这个a前面所有的b，dp次数+前面b的数量。取二者最小</p><p>当末尾是b时，我们直接加到b的个数里</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumDeletions</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="type">int</span> dp=<span class="number">0</span>,countb=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当末尾是a的时候，删除这个a或者保留这个a，删除前面所有的b（b有countb来计数）</span></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;a&#x27;</span>) dp=<span class="built_in">min</span>(dp+<span class="number">1</span>,countb);</span><br><span class="line">            <span class="keyword">else</span> countb++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/05/Scala%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/05/Scala%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一个最初的Hello-world程序"><a href="#1-一个最初的Hello-world程序" class="headerlink" title="1.一个最初的Hello world程序"></a><strong>1.一个最初的Hello world程序</strong></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个 Scala 程序</span></span><br><span class="line"><span class="comment">    * 以下程序将输出&#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">      println(<span class="string">&quot;Hello, world!&quot;</span>) <span class="comment">// 输出 Hello World</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-scala中，每行只有一句时可以不写分号，一行多句要写"><a href="#2-scala中，每行只有一句时可以不写分号，一行多句要写" class="headerlink" title="2.scala中，每行只有一句时可以不写分号，一行多句要写"></a><strong>2.scala中，每行只有一句时可以不写分号，一行多句要写</strong></h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;菜鸟教程&quot;</span>; println(s)</span><br></pre></td></tr></table></figure><h2 id="3-scala包"><a href="#3-scala包" class="headerlink" title="3.scala包"></a><strong>3.scala包</strong></h2><p>和java一样</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题10</title>
      <link href="/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9810/"/>
      <url>/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%9810/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><a href="http://118.190.20.162/view.page?gpid=T159">问题描述</a></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>本题就是关键路径的计算</p><p>70分：只计算最早开始时间</p><p><strong>{</strong></p><p>​如果依赖为0，那么直接置<strong>first[i]&#x3D;1</strong>，然后计算该项目的最早结束时间<strong>need[i]</strong></p><p>​依赖不为0时，找到依赖的项目**yilai[i]<strong>，依赖项目最早结束时间</strong>need[yilai[i]]**就是该项目最早开始时间，然后再计算该项目最早结束时间</p><p><strong>}</strong></p><p>100分：计算最晚开始时间</p><p><strong>{</strong></p><p>​因为题目说，依赖的项目编号一定小于自身，所以我们<strong>倒着遍历</strong></p><p>​如果依赖不为0，那么<strong>last[i]<strong>有两种情况，如果这个</strong>last[i]<strong>已经存在值，说明该项目被别的项目依赖过，那么取</strong>记录值</strong>和<strong>n-needday[i]+1</strong>的最小值，否则<strong>last[i]&#x3D;n-needday[i]+1</strong></p><p>​然后我们计算该项目依赖项目的最晚开始时间，是<strong>本项目的最晚开始时间-依赖项目的耗时</strong>，也就是<strong>last[yilai[i]]&#x3D;last[i]-needday[yilai[i]]</strong>,同样我们需要判断一下**last[yilai[i]]**是否存在，来应对多个项目依赖同一个项目的情况。</p><p>​如果这个<strong>last[yilai[i]]<strong>已经存在值，说明该项目也被别的项目依赖过，那么取</strong>记录值</strong>和<strong>last[i]-needday[yilai[i]]<strong>的最小值，否则</strong>last[yilai[i]]&#x3D;last[i]-needday[yilai[i]]</strong></p><p>​然后再遍历一遍，把与依赖无关的所有其他项目赋上最晚开始时间<strong>last[i]&#x3D;n-needday[i]+1</strong></p><p><strong>}</strong></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">370</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> yilai[N],needday[N];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; first;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; need,needlast;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;yilai[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;needday[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(yilai[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            first[i]=<span class="number">1</span>;</span><br><span class="line">            need[i]=<span class="number">1</span>+needday[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first[i]=need[yilai[i]];</span><br><span class="line">            need[i]=first[i]+needday[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(need[i]<span class="number">-1</span>&gt;n) flag=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=first.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;it!=first.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//70分就不用写下面这个if  100分要算最晚完成时间</span></span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(yilai[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(last[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    last[i]=<span class="built_in">min</span>(last[i],n-needday[i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    last[i]=n-needday[i]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(last[yilai[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    last[yilai[i]]=<span class="built_in">min</span>(last[yilai[i]],last[i]-needday[yilai[i]]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    last[yilai[i]]=last[i]-needday[yilai[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last[i]==<span class="number">0</span>) last[i]=n-needday[i]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it1=last.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(;it1!=last.<span class="built_in">end</span>();it1++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;it1-&gt;second&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CCFCSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题8</title>
      <link href="/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%988/"/>
      <url>/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%988/</url>
      
        <content type="html"><![CDATA[<h4 id="1599-经营摩天轮的最大利润"><a href="#1599-经营摩天轮的最大利润" class="headerlink" title="1599. 经营摩天轮的最大利润"></a><a href="https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/">1599. 经营摩天轮的最大利润</a></h4><p>你正在经营一座摩天轮，该摩天轮共有 <strong>4 个座舱</strong> ，每个座舱 <strong>最多可以容纳 4 位游客</strong> 。你可以 <strong>逆时针</strong> 轮转座舱，但每次轮转都需要支付一定的运行成本 <code>runningCost</code> 。摩天轮每次轮转都恰好转动 1 &#x2F; 4 周。</p><p>给你一个长度为 <code>n</code> 的数组 <code>customers</code> ， <code>customers[i]</code> 是在第 <code>i</code> 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 <code>i</code> 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 <code>boardingCost</code> ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p><p>你可以随时停下摩天轮，即便是 <strong>在服务所有游客之前</strong> 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，<strong>将免费进行****所有后续轮转</strong> 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 <strong>下一次轮转</strong> 。</p><p>返回最大化利润所需执行的 <strong>最小轮转次数</strong> 。 如果不存在利润为正的方案，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/09/26/wheeldiagram12.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [8,3], boardingCost = 5, runningCost = 6</span><br><span class="line">输出：3</span><br><span class="line">解释：座舱上标注的数字是该座舱的当前游客数。</span><br><span class="line">1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。</span><br><span class="line">2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。</span><br><span class="line">3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。</span><br><span class="line">轮转 3 次得到最大利润，最大利润为 $37 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [10,9,6], boardingCost = 6, runningCost = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。</span><br><span class="line">2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。</span><br><span class="line">3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。</span><br><span class="line">4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。</span><br><span class="line">5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。</span><br><span class="line">6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。</span><br><span class="line">7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。</span><br><span class="line">轮转 7 次得到最大利润，最大利润为$122 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。</span><br><span class="line">2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。</span><br><span class="line">3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。</span><br><span class="line">4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。</span><br><span class="line">5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。</span><br><span class="line">利润永不为正，所以返回 -1 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>直接模拟即可，只能说这题有各种限制条件恶心你</p><p><strong>代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123;</span><br><span class="line">        int money=0;</span><br><span class="line">        int people=0;</span><br><span class="line">        int res=0;</span><br><span class="line">        int maxmoney=0;</span><br><span class="line">        for(auto c:customers)</span><br><span class="line">        &#123;</span><br><span class="line">            people+=c;</span><br><span class="line">            if(people&gt;=4)</span><br><span class="line">            &#123;</span><br><span class="line">                money+=4*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;maxmoney)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people-=4;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(people&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                money+=people*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;=maxmoney)  //最后加了个等号才过的最后一个案例，利润在中间可能存在相等的情况</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else  //这里  如果people降到0了也要转一次</span><br><span class="line">            &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(people!=0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(people&gt;=4)</span><br><span class="line">            &#123;</span><br><span class="line">                money+=4*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;maxmoney)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people-=4;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                money+=people*boardingCost-runningCost;</span><br><span class="line">                if(money&gt;maxmoney)</span><br><span class="line">                &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    maxmoney=money;</span><br><span class="line">                &#125;</span><br><span class="line">                people=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(maxmoney==0) return -1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题9</title>
      <link href="/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%989/"/>
      <url>/2023/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%989/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><a href="http://118.190.20.162/view.page?gpid=T160">问题描述</a></h2><p><strong>思路</strong></p><p>模拟即可，注意是输入n+1行数据</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">double</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> i;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> money=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n+<span class="number">1</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;w[k]);</span><br><span class="line">        <span class="keyword">if</span>(w[k]&gt;<span class="number">0</span>) money+=w[k]*<span class="built_in">pow</span>((<span class="number">1</span>+i),-k);</span><br><span class="line">        <span class="keyword">else</span> money+=w[k]*<span class="built_in">pow</span>((<span class="number">1</span>+i),-k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,money);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CCFCSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题6</title>
      <link href="/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%986/"/>
      <url>/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<h4 id="982-按位与为零的三元组"><a href="#982-按位与为零的三元组" class="headerlink" title="982. 按位与为零的三元组"></a><a href="https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/">982. 按位与为零的三元组</a></h4><p>给你一个整数数组 <code>nums</code> ，返回其中 <strong>按位与三元组</strong> 的数目。</p><p><strong>按位与三元组</strong> 是由下标 <code>(i, j, k)</code> 组成的三元组，并满足下述全部条件：</p><ul><li><code>0 &lt;= i &lt; nums.length</code></li><li><code>0 &lt;= j &lt; nums.length</code></li><li><code>0 &lt;= k &lt; nums.length</code></li><li><code>nums[i] &amp; nums[j] &amp; nums[k] == 0</code> ，其中 <code>&amp;</code> 表示按位与运算符。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1,3]</span><br><span class="line">输出：12</span><br><span class="line">解释：可以选出如下 i, j, k 三元组：</span><br><span class="line">(i=0, j=0, k=1) : 2 &amp; 2 &amp; 1</span><br><span class="line">(i=0, j=1, k=0) : 2 &amp; 1 &amp; 2</span><br><span class="line">(i=0, j=1, k=1) : 2 &amp; 1 &amp; 1</span><br><span class="line">(i=0, j=1, k=2) : 2 &amp; 1 &amp; 3</span><br><span class="line">(i=0, j=2, k=1) : 2 &amp; 3 &amp; 1</span><br><span class="line">(i=1, j=0, k=0) : 1 &amp; 2 &amp; 2</span><br><span class="line">(i=1, j=0, k=1) : 1 &amp; 2 &amp; 1</span><br><span class="line">(i=1, j=0, k=2) : 1 &amp; 2 &amp; 3</span><br><span class="line">(i=1, j=1, k=0) : 1 &amp; 1 &amp; 2</span><br><span class="line">(i=1, j=2, k=0) : 1 &amp; 3 &amp; 2</span><br><span class="line">(i=2, j=0, k=1) : 3 &amp; 2 &amp; 1</span><br><span class="line">(i=2, j=1, k=0) : 3 &amp; 1 &amp; 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：27</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>先任选两个数进行位与运算，然后用哈希表储存，再和第三个数位与。</p><p>将结果为0的，直接加上哈希表后面的统计个数，这样可以减少时间复杂度</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; judge;</span><br><span class="line"><span class="comment">//将前两个任选数位与结果存进哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; j:nums)</span><br><span class="line">            &#123;</span><br><span class="line">                judge[i&amp;j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//与第三个数进行位与运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [k,v]:judge)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:nums)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((k&amp;x)==<span class="number">0</span>) res+=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题7</title>
      <link href="/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%987/"/>
      <url>/2023/03/04/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%987/</url>
      
        <content type="html"><![CDATA[<h2 id="何以包邮？"><a href="#何以包邮？" class="headerlink" title="何以包邮？"></a>何以包邮？</h2><p>新学期伊始，适逢顿顿书城有购书满 x元包邮的活动，小 P 同学欣然前往准备买些参考书。</p><p>一番浏览后，小 P 初步筛选出 n本书加入购物车中，其中第 i 本（1≤i≤n）的价格为 ai 元。</p><p>考虑到预算有限，在最终付款前小 P 决定再从购物车中删去几本书（也可以不删），使得剩余图书的价格总和 m 在满足包邮条件（m≥x）的前提下最小。</p><p>试帮助小 P 计算，最终选购哪些书可以在凑够 x 元包邮的前提下花费最小？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行包含空格分隔的两个正整数 n 和 x，分别表示购物车中图书数量和包邮条件。</p><p>接下来输入 n 行，其中第 i 行（1≤i≤n1）仅包含一个正整数 ai，表示购物车中第 i 本书的价格。</p><p>输入数据保证 n 本书的价格总和不小于 x。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>仅输出一个正整数，表示在满足包邮条件下的最小花费。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>70%70% 的测试数据满足：n≤15；<br>全部的测试数据满足：n≤30，每本书的价格 ai≤10^4 且 x≤a1+a2+⋯+an。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 100</span><br><span class="line">20</span><br><span class="line">90</span><br><span class="line">60</span><br><span class="line">60</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110</span><br></pre></td></tr></table></figure><h4 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h4><p>购买前两本书 (20+90) 即可包邮且花费最小。</p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 30</span><br><span class="line">15</span><br><span class="line">40</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="样例2解释"><a href="#样例2解释" class="headerlink" title="样例2解释"></a>样例2解释</h4><p>仅购买第三本书恰好可以满足包邮条件。</p><h4 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 90</span><br><span class="line">50</span><br><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h4 id="样例3解释"><a href="#样例3解释" class="headerlink" title="样例3解释"></a>样例3解释</h4><p>必须全部购买才能包邮。</p><h3 id="解法一：暴力解法（70分）"><a href="#解法一：暴力解法（70分）" class="headerlink" title="解法一：暴力解法（70分）"></a>解法一：暴力解法（70分）</h3><p>用n位二进制数，1代表选了对应位置的书，0代表没选</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span>  w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">1e8</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++)  <span class="comment">//枚举从0到2^n-1的所有的数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) sum+=w[j];  <span class="comment">//在二进制表示当中i的第j位是1 表示选了第j本书</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=m) res=<span class="built_in">min</span>(res,sum); <span class="comment">//如果大于包邮邮费，就更新最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>暴力dfs：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span>  w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res=<span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=m) res=<span class="built_in">min</span>(sum,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(u+<span class="number">1</span>,sum); <span class="comment">//不选这本书</span></span><br><span class="line">        <span class="built_in">dfs</span>(u+<span class="number">1</span>,sum+w[u]); <span class="comment">//选这本书</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二：转换为01背包问题（100分）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题转化为  选择若干本书，使得总和不超过sum-x的前提下，总和越大越好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转化成背包问题：背包容量：sum-x  每个物品的体积 w[i]  每个物品的价值 w[i]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//背包问题两重循环： 先枚举每个物品，再倒序枚举每个体积</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35</span>,M=<span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> f[M]; <span class="comment">//动态规划的数据 长度是最大数量*最大体积</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        sum+=w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m=sum-x;  <span class="comment">//背包容量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始背包问题循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-w[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;sum-f[m]&lt;&lt;endl;  <span class="comment">//f[m]就是最大的结果，再用sum减去</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CCFCSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题5</title>
      <link href="/2023/03/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%985/"/>
      <url>/2023/03/03/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h4 id="1487-保证文件名唯一"><a href="#1487-保证文件名唯一" class="headerlink" title="1487. 保证文件名唯一"></a><a href="https://leetcode.cn/problems/making-file-names-unique/">1487. 保证文件名唯一</a></h4><p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p><p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p><p>返回长度为 <em><code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">输出：[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line">&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;</span><br><span class="line">&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;</span><br><span class="line">&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;</span><br><span class="line">&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]</span><br><span class="line">输出：[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line">&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;</span><br><span class="line">&quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot;</span><br><span class="line">&quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。</span><br><span class="line">&quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]</span><br><span class="line">输出：[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]</span><br><span class="line">解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]</span><br><span class="line">输出：[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]</span><br><span class="line">解释：每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]</span><br><span class="line">输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]</span><br><span class="line">解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><p>用哈希表存储已经创建过的文件名，用k记录后缀次数</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getFolderNames</span><span class="params">(vector&lt;string&gt;&amp; names)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; order;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:names)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(order[t]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t);</span><br><span class="line">                <span class="comment">//记录第一次被创建的文件名</span></span><br><span class="line">                order[t]=<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> k=order[t];</span><br><span class="line">                <span class="keyword">while</span>(order[t+<span class="string">&#x27;(&#x27;</span>+<span class="built_in">to_string</span>(k)+<span class="string">&#x27;)&#x27;</span>]!=<span class="number">0</span>) k++;</span><br><span class="line">                res.<span class="built_in">push_back</span>(t+<span class="string">&#x27;(&#x27;</span>+<span class="built_in">to_string</span>(k)+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                <span class="comment">//优化查询速度，降低时间复杂度  文件t已被记录k次，而带k后缀的文件第一次被记录</span></span><br><span class="line">                order[t]=k+<span class="number">1</span>;</span><br><span class="line">                order[t+<span class="string">&#x27;(&#x27;</span>+<span class="built_in">to_string</span>(k)+<span class="string">&#x27;)&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题4</title>
      <link href="/2023/03/02/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%984/"/>
      <url>/2023/03/02/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h4 id="面试题-05-02-二进制数转字符串"><a href="#面试题-05-02-二进制数转字符串" class="headerlink" title="面试题 05.02. 二进制数转字符串"></a><a href="https://leetcode.cn/problems/bianry-number-to-string-lcci/">面试题 05.02. 二进制数转字符串</a></h4><p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：0.625</span><br><span class="line">输出：&quot;0.101&quot;</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：0.1</span><br><span class="line">输出：&quot;ERROR&quot;</span><br><span class="line">提示：0.1无法被二进制准确表示</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>32位包括输出中的 <code>&quot;0.&quot;</code> 这两位。</li><li>题目保证输入用例的小数位数最多只有 <code>6</code> 位</li></ul><p><strong>思路：</strong></p><p>用一个judge存储计算结果，实时比较对应置0和置1，如果在30(32-2)位内还没有得出结果，就返回ERROR。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">printBin</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        string res=<span class="string">&quot;0.&quot;</span>;</span><br><span class="line">        <span class="type">double</span> judge=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=<span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(judge+(<span class="number">1</span>/<span class="built_in">pow</span>(<span class="number">2</span>,i))&gt;num) res+=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res+=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">                judge+=<span class="number">1</span>/<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(judge==num) <span class="keyword">return</span> res;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 二进制 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题3</title>
      <link href="/2023/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%983/"/>
      <url>/2023/03/01/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h4 id="2373-矩阵中的局部最大值"><a href="#2373-矩阵中的局部最大值" class="headerlink" title="2373. 矩阵中的局部最大值"></a><a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix/">2373. 矩阵中的局部最大值</a></h4><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p><p>生成一个大小为 <code>(n - 2) x (n - 2)</code> 的整数矩阵 <code>maxLocal</code> ，并满足：</p><ul><li><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 <strong>最大值</strong> 。</li></ul><p>换句话说，我们希望找出 <code>grid</code> 中每个 <code>3 x 3</code> 矩阵中的最大值。</p><p>返回生成的矩阵。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/06/21/ex1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]</span><br><span class="line">输出：[[9,9],[8,6]]</span><br><span class="line">解释：原矩阵和生成的矩阵如上图所示。</span><br><span class="line">注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/07/02/ex2new2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]</span><br><span class="line">输出：[[2,2,2],[2,2,2],[2,2,2]]</span><br><span class="line">解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。</span><br></pre></td></tr></table></figure><p>直接模拟即可</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">largestLocal</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> n=grid.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n<span class="number">-2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">-2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">                <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=i+<span class="number">2</span>;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> z=j;z&lt;=j+<span class="number">2</span>;z++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp=<span class="built_in">max</span>(grid[k][z],temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i][j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：二维vector数组的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; 名字(size1, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size2, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 矩阵计算 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题2</title>
      <link href="/2023/02/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%982/"/>
      <url>/2023/02/28/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="力扣每日一题"><a href="#力扣每日一题" class="headerlink" title="力扣每日一题"></a>力扣每日一题</h2><h4 id="2363-合并相似的物品"><a href="#2363-合并相似的物品" class="headerlink" title="2363. 合并相似的物品"></a><a href="https://leetcode.cn/problems/merge-similar-items/">2363. 合并相似的物品</a></h4><p>给你两个二维整数数组 <code>items1</code> 和 <code>items2</code> ，表示两个物品集合。每个数组 <code>items</code> 有以下特质：</p><ul><li><code>items[i] = [valuei, weighti]</code> 其中 <code>valuei</code> 表示第 <code>i</code> 件物品的 <strong>价值</strong> ，<code>weighti</code> 表示第 <code>i</code> 件物品的 <strong>重量</strong> 。</li><li><code>items</code> 中每件物品的价值都是 <strong>唯一的</strong> 。</li></ul><p>请你返回一个二维数组 <code>ret</code>，其中 <code>ret[i] = [valuei, weighti]</code>， <code>weighti</code> 是所有价值为 <code>valuei</code> 物品的 <strong>重量之和</strong> 。</p><p><strong>注意：</strong><code>ret</code> 应该按价值 <strong>升序</strong> 排序后返回。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]</span><br><span class="line">输出：[[1,6],[3,9],[4,5]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。</span><br><span class="line">value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。</span><br><span class="line">value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。</span><br><span class="line">所以，我们返回 [[1,6],[3,9],[4,5]] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]</span><br><span class="line">输出：[[1,4],[2,4],[3,4]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。</span><br><span class="line">value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">所以，我们返回 [[1,4],[2,4],[3,4]] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]</span><br><span class="line">输出：[[1,7],[2,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。</span><br><span class="line">所以，我们返回 [[1,7],[2,4],[7,1]] 。</span><br></pre></td></tr></table></figure><p>思路：使用哈希表将相同价值的重量加在一起，最后再排序即可</p><p>代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items2) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; judge;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:items1)</span><br><span class="line">        &#123;</span><br><span class="line">            judge[t[<span class="number">0</span>]]+=t[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:items2)</span><br><span class="line">        &#123;</span><br><span class="line">            judge[t[<span class="number">0</span>]]+=t[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it=judge.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(;it!=judge.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;it-&gt;first,it-&gt;second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法刷题1</title>
      <link href="/2023/02/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%981/"/>
      <url>/2023/02/27/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="1144-递减元素使数组呈锯齿状"><a href="#1144-递减元素使数组呈锯齿状" class="headerlink" title="1144. 递减元素使数组呈锯齿状"></a>1144. 递减元素使数组呈锯齿状</h2><p>给你一个整数数组 <code>nums</code>，每次 <strong>操作</strong> 会从中选择一个元素并 <strong>将该元素的值减少 1</strong>。</p><p>如果符合下列情况之一，则数组 <code>A</code> 就是 <strong>锯齿数组</strong>：</p><ul><li>每个偶数索引对应的元素都大于相邻的元素，即 <code>A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; ...</code></li><li>或者，每个奇数索引对应的元素都大于相邻的元素，即 <code>A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; ...</code></li></ul><p>返回将数组 <code>nums</code> 转换为锯齿数组所需的最小操作次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以把 2 递减到 0，或把 3 递减到 1。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line">输入：nums = [9,6,1,6,2]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><h2 id="思路：枚举-贪心"><a href="#思路：枚举-贪心" class="headerlink" title="思路：枚举+贪心"></a>思路：枚举+贪心</h2><p>​分别算出偶数索引大和奇数索引大的两种情况需要操作的最小次数，比较求之即可。</p><h2 id="C-代码："><a href="#C-代码：" class="headerlink" title="C++代码："></a>C++代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums1=nums; <span class="comment">//防止第一次计算时数组变化，备份一份</span></span><br><span class="line">        <span class="type">int</span> res1=<span class="number">0</span>,res2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//奇数索引最大时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res1+=nums[i]-nums[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums[i]=nums[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res1+=nums[i]-nums[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums[i]=nums[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//偶数索引最大时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;nums1[i]&gt;=nums1[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res2+=nums1[i]-nums1[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums1[i]=nums1[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n&amp;&amp;nums1[i]&gt;=nums1[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    res2+=nums1[i]-nums1[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    nums1[i]=nums1[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res1,res2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电路考试范围</title>
      <link href="/2023/01/06/%E7%94%B5%E8%B7%AF%E8%80%83%E8%AF%95/"/>
      <url>/2023/01/06/%E7%94%B5%E8%B7%AF%E8%80%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>交作业时间 雨课堂  还有感想意见也要写<br>电路考试题型<br>8个小主观题  6*8&#x3D;48<br>必考内容<br>直流<br>第一章 简单直流电路的分析 KCL KVL 功率<br>第二章 对象化简 二端口网络<br>第四章 叠加定理<br>交流<br>相量法简单计算 简单交流电路<br>谐振（去耦 理想变压器等）<br>非正弦交流 公式<br>三相电路中间的量表法</p><p>五个大题<br>必考<br>1.节点法和回路法（2选1）<br>2.交流电路分析（相量图）<br>3.三相电路分析（对称或简单不对称）计算器<br>4.一阶电路分析<br>5.二端口网络&#x2F;定理综合应用 等 待定</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建历程</title>
      <link href="/2022/12/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/"/>
      <url>/2022/12/29/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2022-12-28"><a href="#2022-12-28" class="headerlink" title="2022.12.28"></a>2022.12.28</h1><p>正式建立博客并设置了背景，添加搜索功能，为顶部底部添加透明css文件等一系列美化措施。</p><h1 id="2023-2-18-2023-2-28"><a href="#2023-2-18-2023-2-28" class="headerlink" title="2023.2.18-2023.2.28"></a>2023.2.18-2023.2.28</h1><ul><li>1.加入了Aplayer播放器</li><li>2.个人卡渐变</li><li>3.首页文章分栏显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2022/12/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>##第一篇文章</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
